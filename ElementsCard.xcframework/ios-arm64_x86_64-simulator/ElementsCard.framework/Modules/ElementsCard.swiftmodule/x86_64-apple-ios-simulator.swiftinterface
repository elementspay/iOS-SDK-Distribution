// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ElementsCard
import Elements
@_exported import ElementsCard
import Foundation
import Swift
import UIKit
public struct CardDetails : Elements.PaymentMethodDetails, Elements.BillingAddressInformation {
  public let type: Swift.String
  public let storedPaymentMethodIdentifier: Swift.String?
  public let card: Elements.ElementsCardParams?
  public let fundingSource: Elements.CardFundingSource?
  public var billingAddress: Elements.AddressInfo?
  public init(paymentMethod: Elements.AnyCardPaymentMethod, card: Elements.ElementsCardParams, holderName: Swift.String? = nil, billingAddress: Elements.AddressInfo? = nil)
  public init(paymentMethod: Elements.StoredCardPaymentMethod, securityCode: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol CardComponentDelegate : AnyObject {
  func didChangeBIN(_ value: Swift.String, component: ElementsCard.CardComponent)
  func didChangeCardBrand(_ value: [ElementsCard.CardBrand]?, component: ElementsCard.CardComponent)
}
public class CardComponent : Elements.PaymentComponent, Elements.PresentableComponent, Elements.Localizable, Elements.Observer, Elements.LoadingComponent {
  final public let style: Elements.FormComponentStyle
  public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak public var cardComponentDelegate: ElementsCard.CardComponentDelegate?
  final public let supportedCardTypes: [ElementsCard.CardType]
  final public let configuration: ElementsCard.CardComponent.Configuration
  weak public var delegate: Elements.PaymentComponentDelegate? {
    get
    set
  }
  public var payment: Elements.Payment? {
    get
    set
  }
  public var environment: Elements.Environment {
    get
    set
  }
  public init(paymentMethod: Elements.AnyCardPaymentMethod, configuration: ElementsCard.CardComponent.Configuration = Configuration(), style: Elements.FormComponentStyle = FormComponentStyle())
  public var viewController: UIKit.UIViewController {
    get
  }
  public var requiresModalPresentation: Swift.Bool {
    get
  }
  public var localizationParameters: Elements.LocalizationParameters?
  public func stopLoading()
  @objc deinit
}
extension Array : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Array<Element>
}
extension ElementsScope where Base == [ElementsCard.CardType] {
  public func types(forCardNumber cardNumber: Swift.String) -> [ElementsCard.CardType]
  public func type(forCardNumber cardNumber: Swift.String) -> ElementsCard.CardType?
}
@_inheritsConvenienceInitializers final public class CardExpiryDateFormatter : Elements.NumericFormatter {
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  @objc deinit
  override public init()
}
public struct StoredCardConfiguration {
  public var showsSecurityCodeField: Swift.Bool
  public init()
}
final public class CardNumberValidator : Elements.Validator {
  public init()
  final public func isValid(_ value: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
final public class CardSecurityCodeValidator : Elements.NumericStringValidator, Elements.Observer {
  public init()
  public init(publisher: Elements.Observable<ElementsCard.CardType?>)
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CardNumberFormatter : Elements.NumericFormatter {
  final public var cardType: ElementsCard.CardType?
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  override public init()
  @objc deinit
}
extension CardComponent {
  public enum AddressFormType {
    case full
    case postalCode
    case none
    public static func == (a: ElementsCard.CardComponent.AddressFormType, b: ElementsCard.CardComponent.AddressFormType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Configuration {
    public var showsHolderNameField: Swift.Bool
    public var showsStorePaymentMethodField: Swift.Bool
    public var showsSecurityCodeField: Swift.Bool
    public var billingAddressMode: ElementsCard.CardComponent.AddressFormType
    public var stored: ElementsCard.StoredCardConfiguration
    public var allowedCardTypes: [ElementsCard.CardType]?
    public init(showsHolderNameField: Swift.Bool = false, showsStorePaymentMethodField: Swift.Bool = true, showsSecurityCodeField: Swift.Bool = true, billingAddressMode: ElementsCard.CardComponent.AddressFormType = .none, storedCardConfiguration: ElementsCard.StoredCardConfiguration = StoredCardConfiguration(), allowedCardTypes: [ElementsCard.CardType]? = nil)
  }
}
extension CardComponent {
  public enum Error : Swift.Error {
    case missingClientKey
    public static func == (a: ElementsCard.CardComponent.Error, b: ElementsCard.CardComponent.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension CardComponent : Elements.TrackableComponent {
  public func viewDidLoad(viewController: UIKit.UIViewController)
}
@_inheritsConvenienceInitializers final public class CardSecurityCodeFormatter : Elements.NumericFormatter, Elements.Observer {
  override public init()
  public init(publisher: Elements.Observable<ElementsCard.CardType?>)
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CardExpiryDateValidator : Elements.Validator {
  public init()
  final public func isValid(_ string: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public struct CardBrand : Swift.Decodable {
  public let type: ElementsCard.CardType
  public let isSupported: Swift.Bool
  public enum CVCPolicy : Swift.String, Swift.Decodable {
    case required
    case optional
    case hidden
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(from decoder: Swift.Decoder) throws
}
extension CardBrand : Swift.Equatable {
  public static func == (a: ElementsCard.CardBrand, b: ElementsCard.CardBrand) -> Swift.Bool
}
public enum CardType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case accel
  case alphaBankBonusMasterCard
  case alphaBankBonusVISA
  case argencard
  case americanExpress
  case bcmc
  case bijenkorfCard
  case cabal
  case carteBancaire
  case cencosud
  case chequeDejeneur
  case chinaUnionPay
  case codensa
  case creditUnion24
  case dankort
  case dankortVISA
  case diners
  case discover
  case elo
  case forbrugsforeningen
  case hiper
  case hipercard
  case jcb
  case karenMillen
  case kcp
  case laser
  case maestro
  case maestroUK
  case masterCard
  case mir
  case naranja
  case netplus
  case nyce
  case oasis
  case pulse
  case shopping
  case solo
  case star
  case troy
  case uatp
  case visa
  case warehouse
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ElementsCard.CardType]
  public static var allCases: [ElementsCard.CardType] {
    get
  }
}
extension ElementsCard.CardComponent.AddressFormType : Swift.Equatable {}
extension ElementsCard.CardComponent.AddressFormType : Swift.Hashable {}
extension ElementsCard.CardComponent.Error : Swift.Equatable {}
extension ElementsCard.CardComponent.Error : Swift.Hashable {}
extension ElementsCard.CardBrand.CVCPolicy : Swift.Equatable {}
extension ElementsCard.CardBrand.CVCPolicy : Swift.Hashable {}
extension ElementsCard.CardBrand.CVCPolicy : Swift.RawRepresentable {}
extension ElementsCard.CardType : Swift.Equatable {}
extension ElementsCard.CardType : Swift.Hashable {}
extension ElementsCard.CardType : Swift.RawRepresentable {}
