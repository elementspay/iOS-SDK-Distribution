// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Elements
import AVKit
import Accelerate
import CommonCrypto
import CoreGraphics
import CoreImage
import Darwin/*.fputs*/
@_exported import Elements
import Foundation
import ImageIO
import MobileCoreServices
import PassKit
import Swift
import UIKit
import WebKit
public struct PaymentsResponse : Elements.Response {
  public let action: Elements.Action?
  public let token: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public protocol BillingAddressInformation {
  var billingAddress: Elements.AddressInfo? { get }
}
public struct PaymentComponentData {
  public let paymentMethod: Elements.PaymentMethodDetails?
  public let storePaymentMethod: Swift.Bool
  public let browserInfo: Elements.BrowserInfo?
  public var billingAddress: Elements.AddressInfo? {
    get
  }
  public init(paymentMethodDetails: Elements.PaymentMethodDetails?, storePaymentMethod: Swift.Bool = false, browserInfo: Elements.BrowserInfo? = nil)
  public func dataByAddingBrowserInfo(completion: @escaping ((Elements.PaymentComponentData) -> Swift.Void))
}
public struct CurrencyCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct AddressStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor? {
    get
  }
}
public protocol ComponentLoader : Elements.LoadingComponent {
  func startLoading(for component: Elements.PaymentComponent)
}
public protocol LoadingComponent {
  func stopLoading()
}
public protocol Component : AnyObject {
  var environment: Elements.Environment { get set }
}
extension Component {
  public func finalizeIfNeeded(with success: Swift.Bool)
  public func cancelIfNeeded()
  public func stopLoadingIfNeeded()
}
public protocol FinalizableComponent : Elements.Component {
  func didFinalize(with success: Swift.Bool)
}
extension Component {
  public var environment: Elements.Environment {
    get
    set
  }
  public var _isDropIn: Swift.Bool {
    get
    set
  }
}
public protocol DismissableComponent : Elements.Component {
  func dismiss(_ animated: Swift.Bool, completion: (() -> Swift.Void)?)
}
public enum BillingAddressFields : Swift.UInt {
  case none
  case postalCode
  case full
  case name
  public typealias RawValue = Swift.UInt
  public init?(rawValue: Swift.UInt)
  public var rawValue: Swift.UInt {
    get
  }
}
public class AddressParams : Swift.Codable {
  public var name: Swift.String?
  public var line1: Swift.String?
  public var line2: Swift.String?
  public var city: Swift.String?
  public var state: Swift.String?
  public var postalCode: Swift.String?
  public var country: Swift.String?
  public var phone: Swift.String?
  public var email: Swift.String?
  public init()
  public init(pkContact contact: PassKit.PKContact)
  public func pkContactValue() -> PassKit.PKContact
  public init(cnContact contact: Contacts.CNContact)
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class FontPlate {
  @objc deinit
}
public protocol FontSchema {
  var primaryTextFont: UIKit.UIFont { get }
  var boldPrimaryTextFont: UIKit.UIFont { get }
  var secondaryTextFont: UIKit.UIFont { get }
  var boldSecondaryTextFont: UIKit.UIFont { get }
  var smallTextFont: UIKit.UIFont { get }
  var largeTextFont: UIKit.UIFont { get }
  var boldLargeTextFont: UIKit.UIFont { get }
}
final public class LightThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
final public class DarkThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
public protocol FormTextItemViewDelegate : AnyObject {
  func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
public protocol AnyFormTextItemView : Elements.AnyFormItemView {
  var delegate: Elements.FormTextItemViewDelegate? { get set }
}
@_inheritsConvenienceInitializers open class FormTextItemView<ItemType> : Elements.FormValueItemView<Swift.String, Elements.FormTextItemStyle, ItemType>, UIKit.UITextFieldDelegate, Elements.AnyFormTextItemView where ItemType : Elements.FormTextItem {
  required public init(item: ItemType)
  weak public var delegate: Elements.FormTextItemViewDelegate?
  public var textField: UIKit.UITextField {
    get
    set
  }
  public var accessory: Elements.FormTextItemView<ItemType>.AccessoryType {
    get
    set
  }
  override public func validate()
  override open func configureSeparatorView()
  @objc override dynamic open var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    @objc get
  }
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @objc public func textFieldShouldReturn(_: UIKit.UITextField) -> Swift.Bool
  @objc open func textFieldDidEndEditing(_: UIKit.UITextField)
  @objc open func textFieldDidBeginEditing(_: UIKit.UITextField)
  open func updateValidationStatus(forced: Swift.Bool = false)
  @objc deinit
}
extension FormTextItemView {
  public enum AccessoryType : Swift.Equatable {
    case invalid
    case valid
    case customView(UIKit.UIView)
    case none
    public static func == (a: Elements.FormTextItemView<ItemType>.AccessoryType, b: Elements.FormTextItemView<ItemType>.AccessoryType) -> Swift.Bool
  }
}
public struct StripeTokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.StripeVaultToken
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListSection {
  public var title: Swift.String?
  public var items: [Elements.ListItem]
  public init(title: Swift.String? = nil, items: [Elements.ListItem])
}
public protocol ViewControllerDelegate : AnyObject {
  func viewDidLoad(viewController: UIKit.UIViewController)
  func viewDidAppear(viewController: UIKit.UIViewController)
}
public protocol Theme : Swift.Equatable {
  var identifier: Swift.String { get }
  static var variants: [Self] { get }
  static var manager: Elements.ThemeManager<Self> { get }
  var colors: Elements.ColorSchema { get set }
  var fonts: Elements.FontSchema { get set }
  var images: Elements.ImageAssets { get set }
}
extension Theme {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class FullFormAddressItem : Elements.FormValueItem<Elements.AddressInfo, Elements.AddressStyle>, Elements.Observer {
  override final public var subitems: [Elements.FormItem] {
    get
  }
  public init(initialCountry: Swift.String, style: Elements.AddressStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public enum ElementsLogging {
  public static var isEnabled: Swift.Bool
}
public func elementsPrint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
@_hasMissingDesignatedInitializers final public class AmountFormatter {
  public static func formatted(amount: Swift.Int, currencyCode: Swift.String) -> Swift.String?
  public static func minorUnitAmount(from majorUnitAmount: Swift.Double, currencyCode: Swift.String) -> Swift.Int
  public static func minorUnitAmount(from majorUnitAmount: Foundation.Decimal, currencyCode: Swift.String) -> Swift.Int
  @objc deinit
}
public class RegularExpressionValidator : Elements.LengthValidator {
  public init(regularExpression: Swift.String, minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  override public func maximumLength(for _: Swift.String) -> Swift.Int
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class NetworkImageView : UIKit.UIImageView {
  public var imageURL: Foundation.URL? {
    get
    set
  }
  @objc override dynamic open func didMoveToWindow()
  @objc deinit
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_hasMissingDesignatedInitializers final public class ContainerView : UIKit.UIView {
  public init(body: UIKit.UIView, padding: UIKit.UIEdgeInsets = .zero)
  final public func setupConstraints()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension AbstractPersonalInformationComponent : Elements.LoadingComponent, Elements.TrackableComponent {
  public func stopLoading()
}
public enum PersonalInformation : Swift.Equatable {
  case firstName
  case lastName
  case email
  case phone
  case custom(Elements.FormItemInjector)
  public static func == (lhs: Elements.PersonalInformation, rhs: Elements.PersonalInformation) -> Swift.Bool
}
extension AbstractPersonalInformationComponent {
  public struct Configuration {
    public let fields: [Elements.PersonalInformation]
    public init(fields: [Elements.PersonalInformation])
  }
}
public protocol ParameterlessInitializable {
  init()
}
extension ElementsScope where Base : UIKit.UIView {
  public func snapShot() -> UIKit.UIImage?
  public func hideWithAnimation(_ hidden: Swift.Bool)
}
public struct EmptyPaymentDetails : Elements.PaymentMethodDetails {
  public let type: Swift.String
  public init(type: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
final public class FormButtonItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let style: Elements.FormButtonItemStyle
  final public var identifier: Swift.String?
  final public var title: Swift.String?
  @Elements.Observable @_projectedValueProperty($showsActivityIndicator) final public var showsActivityIndicator: Swift.Bool {
    get
    set
    _modify
  }
  final public var $showsActivityIndicator: Elements.Observable<Swift.Bool> {
    get
  }
  @Elements.Observable @_projectedValueProperty($enabled) final public var enabled: Swift.Bool {
    get
    set
    _modify
  }
  final public var $enabled: Elements.Observable<Swift.Bool> {
    get
  }
  final public var buttonSelectionHandler: (() -> Swift.Void)?
  public init(style: Elements.FormButtonItemStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public struct WalletsPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let supportedPaymentMethods: [Elements.PaymentMethod]
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(type: Swift.String, name: Swift.String, supportedPaymentMethods: [Elements.PaymentMethod])
}
public class ListItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  final public let style: Elements.ListItemStyle
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var imageURL: Foundation.URL?
  public var showsDisclosureIndicator: Swift.Bool
  public var selectionHandler: (() -> Swift.Void)?
  public var identifier: Swift.String?
  final public let canModifyIcon: Swift.Bool
  public init(title: Swift.String, imageURL: Foundation.URL? = nil, style: Elements.ListItemStyle = ListItemStyle(), showsDisclosureIndicator: Swift.Bool = true, selectionHandler: (() -> Swift.Void)? = nil, canModifyIcon: Swift.Bool = true)
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension ListItem : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Elements.ListItem, rhs: Elements.ListItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
open class FormItemView<ItemType> : UIKit.UIView, Elements.AnyFormItemView, Elements.Observer where ItemType : Elements.FormItem {
  final public let item: ItemType
  required public init(item: ItemType)
  @available(*, unavailable)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  open var childItemViews: [Elements.AnyFormItemView] {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol AnyFormItemView : UIKit.UIView {
  var parentItemView: Elements.AnyFormItemView? { get }
  var childItemViews: [Elements.AnyFormItemView] { get }
}
extension AnyFormItemView {
  public var parentItemView: Elements.AnyFormItemView? {
    get
  }
  public var flatSubitemViews: [Elements.AnyFormItemView] {
    get
  }
}
public struct LocalizationKey {
  public static let submitButton: Elements.LocalizationKey
  public static let submitButtonFormatted: Elements.LocalizationKey
  public static let cancelButton: Elements.LocalizationKey
  public static let dismissButton: Elements.LocalizationKey
  public static let errorTitle: Elements.LocalizationKey
  public static let errorUnknown: Elements.LocalizationKey
  public static let validationAlertTitle: Elements.LocalizationKey
  public static let paymentMethodsOtherMethods: Elements.LocalizationKey
  public static let paymentMethodsTitle: Elements.LocalizationKey
  public static let sepaIbanItemTitle: Elements.LocalizationKey
  public static let sepaIbanItemInvalid: Elements.LocalizationKey
  public static let sepaNameItemTitle: Elements.LocalizationKey
  public static let sepaNameItemPlaceholder: Elements.LocalizationKey
  public static let sepaConsentLabel: Elements.LocalizationKey
  public static let sepaNameItemInvalid: Elements.LocalizationKey
  public static let cardStoreDetailsButton: Elements.LocalizationKey
  public static let cardNameItemTitle: Elements.LocalizationKey
  public static let cardNameItemPlaceholder: Elements.LocalizationKey
  public static let cardNameItemInvalid: Elements.LocalizationKey
  public static let cardNumberItemTitle: Elements.LocalizationKey
  public static let cardNumberItemPlaceholder: Elements.LocalizationKey
  public static let cardNumberItemInvalid: Elements.LocalizationKey
  public static let cardExpiryItemTitle: Elements.LocalizationKey
  public static let cardExpiryItemPlaceholder: Elements.LocalizationKey
  public static let cardExpiryItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemTitle: Elements.LocalizationKey
  public static let cardCvcItemPlaceholder: Elements.LocalizationKey
  public static let cardStoredTitle: Elements.LocalizationKey
  public static let cardStoredMessage: Elements.LocalizationKey
  public static let cardStoredExpires: Elements.LocalizationKey
  public static let dropInStoredTitle: Elements.LocalizationKey
  public static let dropInPreselectedOpenAllTitle: Elements.LocalizationKey
  public static let continueTo: Elements.LocalizationKey
  public static let phoneNumberTitle: Elements.LocalizationKey
  public static let phoneNumberInvalid: Elements.LocalizationKey
  public static let phoneNumberPlaceholder: Elements.LocalizationKey
  public static let cardCvcItemPlaceholderDigits: Elements.LocalizationKey
  public static let emailItemTitle: Elements.LocalizationKey
  public static let emailItemPlaceHolder: Elements.LocalizationKey
  public static let emailItemInvalid: Elements.LocalizationKey
  public static let mbwayConfirmPayment: Elements.LocalizationKey
  public static let awaitWaitForConfirmation: Elements.LocalizationKey
  public static let blikConfirmPayment: Elements.LocalizationKey
  public static let blikInvalid: Elements.LocalizationKey
  public static let blikCode: Elements.LocalizationKey
  public static let blikHelp: Elements.LocalizationKey
  public static let blikPlaceholder: Elements.LocalizationKey
  public static let preauthorizeWith: Elements.LocalizationKey
  public static let confirmPreauthorization: Elements.LocalizationKey
  public static let cardCvcItemTitleOptional: Elements.LocalizationKey
  public static let confirmPurchase: Elements.LocalizationKey
  public static let lastName: Elements.LocalizationKey
  public static let firstName: Elements.LocalizationKey
  public static let cardPinTitle: Elements.LocalizationKey
  public static let missingField: Elements.LocalizationKey
  public static let cardApplyGiftcard: Elements.LocalizationKey
  public static let voucherCollectionInstitutionNumber: Elements.LocalizationKey
  public static let voucherMerchantName: Elements.LocalizationKey
  public static let voucherExpirationDate: Elements.LocalizationKey
  public static let voucherPaymentReferenceLabel: Elements.LocalizationKey
  public static let voucherShopperName: Elements.LocalizationKey
  public static let buttonCopy: Elements.LocalizationKey
  public static let voucherIntroduction: Elements.LocalizationKey
  public static let voucherReadInstructions: Elements.LocalizationKey
  public static let voucherSaveImage: Elements.LocalizationKey
  public static let voucherFinish: Elements.LocalizationKey
  public static let pixInstructions: Elements.LocalizationKey
  public static let pixCopyButton: Elements.LocalizationKey
  public static let pixExpirationLabel: Elements.LocalizationKey
  public static let billingAddressSectionTitle: Elements.LocalizationKey
  public static let deliveryAddressSectionTitle: Elements.LocalizationKey
  public static let countryFieldTitle: Elements.LocalizationKey
  public static let addressFieldTitle: Elements.LocalizationKey
  public static let addressFieldPlaceholder: Elements.LocalizationKey
  public static let streetFieldTitle: Elements.LocalizationKey
  public static let streetFieldPlaceholder: Elements.LocalizationKey
  public static let houseNumberFieldTitle: Elements.LocalizationKey
  public static let houseNumberFieldPlaceholder: Elements.LocalizationKey
  public static let cityFieldTitle: Elements.LocalizationKey
  public static let cityFieldPlaceholder: Elements.LocalizationKey
  public static let cityTownFieldTitle: Elements.LocalizationKey
  public static let cityTownFieldPlaceholder: Elements.LocalizationKey
  public static let postalCodeFieldTitle: Elements.LocalizationKey
  public static let postalCodeFieldPlaceholder: Elements.LocalizationKey
  public static let zipCodeFieldTitle: Elements.LocalizationKey
  public static let zipCodeFieldPlaceholder: Elements.LocalizationKey
  public static let stateFieldTitle: Elements.LocalizationKey
  public static let stateFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateFieldPlaceholder: Elements.LocalizationKey
  public static let stateOrProvinceFieldTitle: Elements.LocalizationKey
  public static let stateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldTitle: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldPlaceholder: Elements.LocalizationKey
  public static let apartmentSuiteFieldTitle: Elements.LocalizationKey
  public static let apartmentSuiteFieldPlaceholder: Elements.LocalizationKey
  public static let errorFeedbackEmptyField: Elements.LocalizationKey
  public static let errorFeedbackIncorrectFormat: Elements.LocalizationKey
  public static let fieldTitleOptional: Elements.LocalizationKey
  public init(key: Swift.String)
}
public struct ThreeDS2FingerprintAction : Swift.Decodable {
  public let fingerprintToken: Swift.String
  public let authorisationToken: Swift.String?
  public let paymentData: Swift.String?
  public init(fingerprintToken: Swift.String, authorisationToken: Swift.String? = nil, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
@objc(ELEFormViewController) open class FormViewController : UIKit.UIViewController, Elements.Localizable, Elements.KeyboardObserver, Elements.Observer, Elements.PreferredContentSizeConsumer {
  public var requiresKeyboardInput: Swift.Bool {
    get
  }
  final public let style: Elements.ViewStyle
  weak public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ViewStyle)
  @objc deinit
  @available(*, unavailable)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  public var keyboardObserver: Any?
  public func startObserving()
  public func willUpdatePreferredContentSize()
  public func didUpdatePreferredContentSize()
  public func append<T>(_ item: T) where T : Elements.FormItem
  public var localizationParameters: Elements.LocalizationParameters?
  public func validate() -> Swift.Bool
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @discardableResult
  @objc override dynamic public func resignFirstResponder() -> Swift.Bool
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension FormViewController : Elements.FormTextItemViewDelegate {
  public func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  public func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
public struct RedirectAction : Swift.Decodable {
  public let url: Foundation.URL
  public let paymentData: Swift.String?
  public init(url: Foundation.URL, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
@propertyWrapper final public class Observable<ValueType> : Elements.EventPublisher where ValueType : Swift.Equatable {
  public init(_ value: ValueType)
  final public var wrappedValue: ValueType {
    get
    set
  }
  public typealias Event = ValueType
  final public var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Elements.Observable<ValueType>.Event>]
  final public var projectedValue: Elements.Observable<ValueType> {
    get
  }
  @objc deinit
}
public struct PhoneExtension : Swift.Decodable, Swift.Equatable {
  public let value: Swift.String
  public let countryCode: Swift.String
  public var countryDisplayName: Swift.String {
    get
  }
  public init(value: Swift.String, countryCode: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.PhoneExtension, b: Elements.PhoneExtension) -> Swift.Bool
}
public enum PhoneNumberPaymentMethod {
  case qiwiWallet
  case mbWay
  case generic
  public static func == (a: Elements.PhoneNumberPaymentMethod, b: Elements.PhoneNumberPaymentMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct PhoneExtensionsQuery {
  public let codes: [Swift.String]
  public init(codes: [Swift.String])
  public init(paymentMethod: Elements.PhoneNumberPaymentMethod)
}
public enum PhoneExtensionsRepository {
  public static func get(with query: Elements.PhoneExtensionsQuery) -> [Elements.PhoneExtension]
}
public struct ElementsScope<Base> {
  public let base: Base
  public init(base: Base)
}
public protocol ElementsCompatible {
  associatedtype ElementsBase
  var elements: Elements.ElementsScope<Self.ElementsBase> { get }
}
extension ElementsCompatible {
  public var elements: Elements.ElementsScope<Self> {
    get
  }
}
public struct ListItemStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var subtitle: Elements.TextStyle
  public var image: Elements.ImageStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle, subtitle: Elements.TextStyle, image: Elements.ImageStyle)
  public init()
}
extension ListItemStyle : Swift.Equatable {
  public static func == (lhs: Elements.ListItemStyle, rhs: Elements.ListItemStyle) -> Swift.Bool
}
public protocol APIEnvironment {
  var baseURL: Foundation.URL { get }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
}
public protocol Validator {
  func isValid(_ value: Swift.String) -> Swift.Bool
  func maximumLength(for value: Swift.String) -> Swift.Int
}
public struct PaymentMethods : Swift.Decodable {
  public let regular: [Elements.PaymentMethod]
  public let stored: [Elements.StoredPaymentMethod]
  public init(regular: [Elements.PaymentMethod], stored: [Elements.StoredPaymentMethod])
  public func paymentMethod<T>(ofType type: T.Type) -> T? where T : Elements.PaymentMethod
  public init(from decoder: Swift.Decoder) throws
}
public enum AnyPaymentMethod : Swift.Decodable {
  case storedCard(Elements.StoredCardPaymentMethod)
  case storedPayPal(Elements.StoredPayPalPaymentMethod)
  case storedRedirect(Elements.StoredRedirectPaymentMethod)
  case card(Elements.AnyCardPaymentMethod)
  case issuerList(Elements.IssuerListPaymentMethod)
  case redirect(Elements.RedirectPaymentMethod)
  case applePay(Elements.ApplePayPaymentMethod)
  case wallets(Elements.WalletsPaymentMethod)
  case none
  public var value: Elements.PaymentMethod? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum AnyStoredPaymentMethod : Swift.Decodable {
  case storedCard(Elements.StoredCardPaymentMethod)
  case storedPayPal(Elements.StoredPayPalPaymentMethod)
  case storedRedirect(Elements.StoredRedirectPaymentMethod)
  case none
  public var value: Elements.PaymentMethod? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
final public class FormSeparatorItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let color: UIKit.UIColor
  final public var identifier: Swift.String?
  public init(color: UIKit.UIColor)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol PresentationDelegate : AnyObject {
  func present(component: Elements.PresentableComponent)
}
public protocol APIClientProtocol {
  typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  func perform<R>(_ request: R, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class APIClient : Elements.APIClientProtocol {
  public typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  final public let environment: Elements.APIEnvironment
  public init(environment: Elements.APIEnvironment)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.APIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@_inheritsConvenienceInitializers open class NumericStringValidator : Elements.LengthValidator {
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  @objc deinit
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
}
extension UIActivityIndicatorView.Style {
}
@_inheritsConvenienceInitializers final public class FormTextInputItem : Elements.FormTextItem {
  override public init(style: Elements.FormTextItemStyle = .init())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol AnyCardPaymentMethod : Elements.PaymentMethod {
  var cardData: [Elements.SupportedCardData] { get }
  var fundingSource: Elements.CardFundingSource? { get }
}
public enum CardFundingSource : Swift.String, Swift.Codable {
  case debit
  case credit
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol AnyAppLauncher {
  func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
public struct AppLauncher : Elements.AnyAppLauncher {
  public init()
  public func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  public func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
public typealias Completion<T> = (T) -> Swift.Void
public enum ThreeDS2Action : Swift.Decodable {
  case fingerprint(Elements.ThreeDS2FingerprintAction)
  case challenge(Elements.ThreeDS2ChallengeAction)
  public init(from decoder: Swift.Decoder) throws
  public enum ActionType : Swift.String, Swift.Decodable {
    case fingerprint
    case challenge
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
extension UIButton {
  convenience public init(style: Elements.ButtonStyle)
}
public func localizedString(_ key: Elements.LocalizationKey, _ parameters: Elements.LocalizationParameters?, _ arguments: Swift.CVarArg...) -> Swift.String
public enum PaymentStyle {
  case needsRedirectToThirdParty(Swift.String)
  case immediate
}
public func localizedSubmitButtonTitle(with amount: Elements.Payment.Amount?, style: Elements.PaymentStyle, _ parameters: Elements.LocalizationParameters?) -> Swift.String
@objc final public class ListViewController : UIKit.UITableViewController {
  final public let style: Elements.ListComponentStyle
  weak final public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ListComponentStyle = ListComponentStyle())
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  final public var sections: [Elements.ListSection] {
    get
    set
  }
  final public func startLoading(for item: Elements.ListItem)
  final public func stopLoading()
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @objc override final public func numberOfSections(in _: UIKit.UITableView) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override final public func tableView(_: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc override final public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override final public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public enum ShopperInteraction : Swift.String, Swift.Decodable {
  case shopperPresent
  case shopperNotPresent
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct FormButtonItemStyle : Elements.ViewStyle {
  public var button: Elements.ButtonStyle
  public var backgroundColor: UIKit.UIColor
  public init(button: Elements.ButtonStyle)
  public init(button: Elements.ButtonStyle, background: UIKit.UIColor)
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRounding: Elements.CornerRounding) -> Elements.FormButtonItemStyle
  public static func secondary(font: UIKit.UIFont, textColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
}
public class FormLabelItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(text: Swift.String, style: Elements.TextStyle, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var style: Elements.TextStyle
  public var text: Swift.String
  public func build(with _: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public class FormContainerItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(content: Elements.FormItem, padding: UIKit.UIEdgeInsets = .zero, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var content: Elements.FormItem {
    get
  }
  public var padding: UIKit.UIEdgeInsets
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension FormItem {
  public func withPadding(padding: UIKit.UIEdgeInsets) -> Elements.FormContainerItem
}
public struct ImageStyle : Elements.TintableStyle {
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var cornerRounding: Elements.CornerRounding
  public var clipsToBounds: Swift.Bool
  public var contentMode: UIKit.UIView.ContentMode
  public var backgroundColor: UIKit.UIColor
  public var tintColor: UIKit.UIColor?
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRadius: CoreGraphics.CGFloat, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRounding: Elements.CornerRounding, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
}
extension ImageStyle : Swift.Equatable {
  public static func == (lhs: Elements.ImageStyle, rhs: Elements.ImageStyle) -> Swift.Bool
}
public protocol Observer : AnyObject {
}
extension Observer {
  @discardableResult
  public func observe<T>(_ eventPublisher: T, eventHandler: @escaping Elements.EventHandler<T.Event>) -> Elements.Observation where T : Elements.EventPublisher
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>, with transformation: @escaping ((Value) -> Result)) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  public func remove(_ observation: Elements.Observation)
}
public struct PhoneExtensionViewModel : Swift.CustomStringConvertible, Swift.Equatable {
  public let title: Swift.String
  public let phoneExtension: Swift.String
  public var description: Swift.String {
    get
  }
  public static func == (a: Elements.PhoneExtensionViewModel, b: Elements.PhoneExtensionViewModel) -> Swift.Bool
}
public typealias PhoneExtensionPickerItem = Elements.BasePickerElement<Elements.PhoneExtensionViewModel>
@_hasMissingDesignatedInitializers final public class FormPhoneExtensionPickerItem : Elements.BaseFormPickerItem<Elements.PhoneExtensionViewModel> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public typealias RegionPickerItem = Elements.BasePickerElement<Elements.Region>
@_hasMissingDesignatedInitializers final public class FormRegionPickerItem : Elements.BaseFormPickerItem<Elements.Region> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public struct ListComponentStyle : Elements.ViewStyle {
  public var listItem: Elements.ListItemStyle
  public var sectionHeader: Elements.ListSectionHeaderStyle
  public var backgroundColor: UIKit.UIColor
  public init(listItem: Elements.ListItemStyle, sectionHeader: Elements.ListSectionHeaderStyle)
  public init()
}
extension Bundle : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.Bundle
}
extension ElementsScope where Base : Foundation.Bundle {
  public func isSchemeConfigured(_ scheme: Swift.String) -> Swift.Bool
}
public struct Region : Swift.Decodable, Swift.CustomStringConvertible, Swift.Equatable {
  public let identifier: Swift.String
  public let name: Swift.String
  public var description: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.Region, b: Elements.Region) -> Swift.Bool
}
public class RegionRepository {
  public init(environment: Elements.Environment)
  public func getCountries(locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  public func getSubRegions(for countryCode: Swift.String, locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  @objc deinit
}
public enum AppImageName : Swift.String {
  case applePayIcon
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum ImageResources {
}
public protocol ImageAssets {
}
final public class LightThemeAssets : Elements.ImageAssets {
  public init()
  @objc deinit
}
final public class DarkThemeAssets : Elements.ImageAssets {
  public init()
  @objc deinit
}
infix operator |> : AdditionPrecedence
public enum HTTPMethod : Swift.String {
  case post
  case get
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public protocol Request : Swift.Encodable {
  associatedtype ResponseType : Elements.Response
  var path: Swift.String { get }
  var counter: Swift.UInt { get set }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
  var method: Elements.HTTPMethod { get }
}
extension Request {
  public var idempotencyKeyHeader: [Swift.String : Swift.String] {
    get
  }
}
public protocol Response : Swift.Decodable {
}
public protocol PaymentComponentBuilder {
  func build(paymentMethod: Elements.StoredCardPaymentMethod) -> Elements.PaymentComponent?
  func build(paymentMethod: Elements.StoredPaymentMethod) -> Elements.PaymentComponent?
  func build(paymentMethod: Elements.CardPaymentMethod) -> Elements.PaymentComponent?
  func build(paymentMethod: Elements.ApplePayPaymentMethod) -> Elements.PaymentComponent?
  func build(paymentMethod: Elements.WalletsPaymentMethod) -> Elements.PaymentComponent?
  func build(paymentMethod: Elements.PaymentMethod) -> Elements.PaymentComponent?
}
final public class StoredPaymentMethodComponent : Elements.PaymentComponent, Elements.PresentableComponent, Elements.Localizable {
  final public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak final public var delegate: Elements.PaymentComponentDelegate?
  public init(paymentMethod: Elements.StoredPaymentMethod)
  final public var viewController: UIKit.UIViewController {
    get
    set
  }
  final public var localizationParameters: Elements.LocalizationParameters?
  @objc deinit
}
public struct StoredPaymentDetails : Elements.PaymentMethodDetails {
  public init(paymentMethod: Elements.StoredPaymentMethod)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct LocalizationParameters : Swift.Equatable {
  public let locale: Swift.String?
  public let tableName: Swift.String?
  public let keySeparator: Swift.String?
  public let bundle: Foundation.Bundle?
  public init(bundle: Foundation.Bundle? = nil, tableName: Swift.String? = nil, keySeparator: Swift.String? = nil, locale: Swift.String? = nil)
  public static func == (a: Elements.LocalizationParameters, b: Elements.LocalizationParameters) -> Swift.Bool
}
public struct ApplePayPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let brands: [Swift.String]?
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(type: Swift.String, name: Swift.String, brands: [Swift.String]?)
  public init(from decoder: Swift.Decoder) throws
}
public struct AddressInfo : Swift.Equatable, Swift.Encodable {
  public init(city: Swift.String? = nil, country: Swift.String? = nil, houseNumberOrName: Swift.String? = nil, postalCode: Swift.String? = nil, stateOrProvince: Swift.String? = nil, street: Swift.String? = nil, apartment: Swift.String? = nil)
  public var city: Swift.String?
  public var country: Swift.String?
  public var houseNumberOrName: Swift.String?
  public var postalCode: Swift.String?
  public var stateOrProvince: Swift.String?
  public var street: Swift.String?
  public var apartment: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: Elements.AddressInfo, b: Elements.AddressInfo) -> Swift.Bool
}
public struct ListSectionHeaderStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
@_inheritsConvenienceInitializers final public class FormSwitchItemView : Elements.FormValueItemView<Swift.Bool, Elements.FormSwitchItemStyle, Elements.FormSwitchItem> {
  required public init(item: Elements.FormSwitchItem)
  @objc override final public func accessibilityActivate() -> Swift.Bool
  @objc deinit
}
public protocol KeyboardObserver : AnyObject {
  func startObserving()
  func stopObserving()
  var keyboardObserver: Any? { get set }
}
extension KeyboardObserver {
  public func startObserving(_ observer: @escaping (CoreGraphics.CGRect) -> Swift.Void)
  public func stopObserving()
}
final public class PhoneNumberValidator : Elements.RegularExpressionValidator {
  public init()
  override public init(regularExpression: Swift.String, minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
public struct ButtonStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat, background: UIKit.UIColor)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding, background: UIKit.UIColor)
}
public class ElementsCardParams : Swift.Codable {
  final public let cardNumber: Swift.String
  final public let expiryMonth: Swift.UInt?
  final public let expiryYear: Swift.UInt?
  final public let securityCode: Swift.String?
  final public let holderName: Swift.String?
  public var address: Elements.AddressParams?
  public init(cardNumber: Swift.String, expiryMonth: Swift.UInt?, expiryYear: Swift.UInt?, securityCode: Swift.String?, holderName: Swift.String?)
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias AssertionListner = (Swift.String) -> Swift.Void
public enum ElementsAssertion {
  public static func assert(message: Swift.String)
}
public struct Observation : Swift.Hashable {
  public static func == (lhs: Elements.Observation, rhs: Elements.Observation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Formatter {
  func formattedValue(for value: Swift.String) -> Swift.String
  func sanitizedValue(for value: Swift.String) -> Swift.String
}
public struct TextStyle : Elements.ViewStyle {
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var textAlignment: UIKit.NSTextAlignment
  public var backgroundColor: UIKit.UIColor
  public var cornerRounding: Elements.CornerRounding
  public init(font: UIKit.UIFont, color: UIKit.UIColor, textAlignment: UIKit.NSTextAlignment)
  public init(font: UIKit.UIFont, color: UIKit.UIColor)
}
extension TextStyle : Swift.Equatable {
  public static func == (lhs: Elements.TextStyle, rhs: Elements.TextStyle) -> Swift.Bool
}
public protocol ColorSchema {
  var themeColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
  var lightBackgroundColor: UIKit.UIColor { get }
  var shadowColor: UIKit.UIColor { get }
  var primaryTextColorDarkCanvas: UIKit.UIColor { get }
  var secondaryTextColorDarkCanvas: UIKit.UIColor { get }
  var primaryTextColorLightCanvas: UIKit.UIColor { get }
  var secondaryTextColorLightCanvas: UIKit.UIColor { get }
  var errorColor: UIKit.UIColor { get }
  var separatorColor: UIKit.UIColor { get }
}
final public class LightThemeColors : Elements.ColorSchema {
  public init()
  final public var themeColor: UIKit.UIColor {
    get
  }
  final public var backgroundColor: UIKit.UIColor {
    get
  }
  final public var lightBackgroundColor: UIKit.UIColor {
    get
  }
  final public var shadowColor: UIKit.UIColor {
    get
  }
  final public var primaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var primaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var separatorColor: UIKit.UIColor {
    get
  }
  final public var errorColor: UIKit.UIColor {
    get
  }
  @objc deinit
}
public enum Action : Swift.Decodable {
  case redirect(Elements.RedirectAction)
  public init(from decoder: Swift.Decoder) throws
}
public struct FormItemViewBuilder {
  public func build(with item: Elements.FormSwitchItem) -> Elements.FormItemView<Elements.FormSwitchItem>
  public func build(with item: Elements.FormSplitItem) -> Elements.FormItemView<Elements.FormSplitItem>
  public func build(with item: Elements.FormPhoneNumberItem) -> Elements.FormItemView<Elements.FormPhoneNumberItem>
  public func build(with item: Elements.FormPhoneExtensionPickerItem) -> Elements.BaseFormPickerItemView<Elements.PhoneExtensionViewModel>
  public func build(with item: Elements.FormRegionPickerItem) -> Elements.BaseFormPickerItemView<Elements.Region>
  public func build(with item: Elements.FormTextInputItem) -> Elements.FormItemView<Elements.FormTextInputItem>
  public func build(with item: Elements.ListItem) -> Elements.ListItemView
  public func build(with item: Elements.FormButtonItem) -> Elements.FormItemView<Elements.FormButtonItem>
  public func build(with item: Elements.FormSeparatorItem) -> Elements.FormItemView<Elements.FormSeparatorItem>
  public func build(with item: Elements.FormErrorItem) -> Elements.FormItemView<Elements.FormErrorItem>
  public func build(with item: Elements.FullFormAddressItem) -> Elements.FormItemView<Elements.FullFormAddressItem>
  public static func build(_ item: Elements.FormItem) -> Elements.AnyFormItemView
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc deinit
  @objc override dynamic public init()
}
extension SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct ContactDetail : Swift.Codable {
  public let emailAdress: Swift.String?
  public let phoneNumber: Swift.String?
  public let postalAddress: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
final public class LogoURLProvider {
  public init(environment: Elements.Environment)
  final public func logoURL(for paymentMethod: Elements.PaymentMethod, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  final public func logoURL(for issuer: Elements.IssuerListPaymentMethod.Issuer, paymentMethod: Elements.IssuerListPaymentMethod) -> Foundation.URL
  final public func logoURL(withName name: Swift.String, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  public static func logoURL(for paymentMethod: Elements.PaymentMethod, environment: Elements.Environment, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  public static func logoURL(for issuer: Elements.IssuerListPaymentMethod.Issuer, paymentMethod: Elements.IssuerListPaymentMethod, environment: Elements.Environment) -> Foundation.URL
  public static func logoURL(withName name: Swift.String, environment: Elements.Environment, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  @objc deinit
}
extension LogoURLProvider {
  public enum Size : Swift.String {
    case small
    case medium
    case large
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
public protocol PaymentMethodAware {
  var paymentMethod: Elements.PaymentMethod { get }
}
public protocol PaymentComponent : Elements.PaymentAwareComponent, Elements.PaymentMethodAware {
  var delegate: Elements.PaymentComponentDelegate? { get set }
}
extension PaymentComponent {
  public func submit(data: Elements.PaymentComponentData, component: Elements.PaymentComponent? = nil)
}
public protocol PaymentComponentDelegate : AnyObject {
  func didSubmit(_ data: Elements.PaymentComponentData, from component: Elements.PaymentComponent)
  func didFail(with error: Swift.Error, from component: Elements.PaymentComponent)
}
public protocol PaymentAwareComponent : Elements.Component {
  var payment: Elements.Payment? { get set }
}
extension PaymentAwareComponent {
  public var payment: Elements.Payment? {
    get
    set
  }
}
extension URLSession : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.URLSession
}
extension ElementsScope where Base : Foundation.URLSession {
  public func dataTask(with url: Foundation.URL, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
  public func dataTask(with urlRequest: Foundation.URLRequest, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
}
extension ElementsScope where Base : UIKit.UIViewController {
  public var topPresenter: UIKit.UIViewController {
    get
  }
  public func present(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
}
extension UIResponder : Elements.ElementsCompatible {
  public typealias ElementsBase = UIKit.UIResponder
}
public protocol PreferredContentSizeConsumer {
  func didUpdatePreferredContentSize()
  func willUpdatePreferredContentSize()
}
public struct FormTextItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var text: Elements.TextStyle
  public var placeholderText: Elements.TextStyle?
  public var icon: Elements.ImageStyle
  public var tintColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public init(title: Elements.TextStyle, text: Elements.TextStyle, placeholderText: Elements.TextStyle? = nil, icon: Elements.ImageStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
final public class PresentableComponentWrapper : Elements.PresentableComponent, Elements.Cancellable, Elements.FinalizableComponent, Elements.LoadingComponent {
  final public let viewController: UIKit.UIViewController
  final public let component: Elements.Component
  final public var requiresModalPresentation: Swift.Bool
  public init(component: Elements.Component, viewController: UIKit.UIViewController)
  final public func didCancel()
  final public func didFinalize(with success: Swift.Bool)
  final public func stopLoading()
  @objc deinit
}
public struct TokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.TokenizationResponse
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
}
public enum ViewIdentifierBuilder {
  public static func build(scopeInstance: Any, postfix: Swift.String) -> Swift.String
}
public struct AnyEncodable : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
open class NumericFormatter : Elements.Formatter {
  public init()
  open func formattedValue(for value: Swift.String) -> Swift.String
  open func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol FormValueItemStyle : Elements.TintableStyle {
  var separatorColor: UIKit.UIColor? { get }
  var title: Elements.TextStyle { get }
}
@_hasMissingDesignatedInitializers open class FormValueItem<ValueType, StyleType> : Elements.FormItem where ValueType : Swift.Equatable, StyleType : Elements.FormValueItemStyle {
  public var subitems: [Elements.FormItem] {
    get
  }
  public var identifier: Swift.String?
  public var value: ValueType {
    get
    set
  }
  public var publisher: Elements.Observable<ValueType>
  public var style: StyleType
  @Elements.Observable @_projectedValueProperty($title) public var title: Swift.String? {
    get
    set
    _modify
  }
  public var $title: Elements.Observable<Swift.String?> {
    get
  }
  open func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FormSwitchItem : Elements.FormValueItem<Swift.Bool, Elements.FormSwitchItemStyle> {
  public init(style: Elements.FormSwitchItemStyle = FormSwitchItemStyle())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc final public class SubmitButton : UIKit.UIControl {
  public init(style: Elements.ButtonStyle)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var title: Swift.String? {
    get
    set
  }
  @objc override final public var accessibilityIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  final public var showsActivityIndicator: Swift.Bool {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc public class StripeCardParam : ObjectiveC.NSObject, Elements.STPFormEncodable {
  @objc public var number: Swift.String
  @objc public var expMonth: Swift.UInt
  @objc public var expYear: Swift.UInt
  @objc public var cvc: Swift.String?
  @objc public var name: Swift.String?
  @objc public var currency: Swift.String?
  @objc public var additionalAPIParameters: [Swift.AnyHashable : Any]
  @objc public var addressLine1: Swift.String? {
    @objc get
    @objc set(addressLine1)
  }
  @objc public var addressLine2: Swift.String? {
    @objc get
    @objc set(addressLine2)
  }
  @objc public var addressCity: Swift.String? {
    @objc get
    @objc set(addressCity)
  }
  @objc public var addressState: Swift.String? {
    @objc get
    @objc set(addressState)
  }
  @objc public var addressZip: Swift.String? {
    @objc get
    @objc set(addressZip)
  }
  @objc public var addressCountry: Swift.String? {
    @objc get
    @objc set(addressCountry)
  }
  public init(number: Swift.String, expMonth: Swift.UInt = 0, expYear: Swift.UInt = 0, cvc: Swift.String?, name: Swift.String?, currency: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
  @objc public class func rootObjectName() -> Swift.String?
  @objc public class func propertyNamesToFormFieldNamesMapping() -> [Swift.String : Swift.String]
  @objc deinit
  @objc override dynamic public init()
}
@objc @_hasMissingDesignatedInitializers final public class ELEViewController : UIKit.UIViewController {
  public init(view: UIKit.UIView, title: Swift.String? = nil)
  @objc override final public func loadView()
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol Hidable {
  var isHidden: Elements.Observable<Swift.Bool> { get }
}
public protocol FormItem : AnyObject {
  var identifier: Swift.String? { get set }
  var subitems: [Elements.FormItem] { get }
  func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
}
extension FormItem {
  public var flatSubitems: [Elements.FormItem] {
    get
  }
}
public protocol ValidatableFormItem : Elements.FormItem {
  var validationFailureMessage: Swift.String? { get set }
  func isValid() -> Swift.Bool
}
public protocol InputViewRequiringFormItem : Elements.FormItem {
}
public struct FormComponentStyle : Elements.TintableStyle {
  public var backgroundColor: UIKit.UIColor
  public var sectionHeader: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var `switch`: Elements.FormSwitchItemStyle
  public var hintLabel: Elements.TextStyle
  public var mainButtonItem: Elements.FormButtonItemStyle
  public var secondaryButtonItem: Elements.FormButtonItemStyle
  public var separatorColor: UIKit.UIColor? {
    get
    set
  }
  public var addressStyle: Elements.AddressStyle {
    get
  }
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.FormButtonItemStyle, secondaryButton: Elements.FormButtonItemStyle, helper: Elements.TextStyle, sectionHeader: Elements.TextStyle)
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.ButtonStyle, secondaryButton: Elements.ButtonStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
public struct SimpleScheduler : Elements.Scheduler {
  public init(maximumCount: Swift.Int)
  public func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public struct FormErrorItemStyle : Elements.ViewStyle {
  public var message: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var backgroundColor: UIKit.UIColor
  public init(message: Elements.TextStyle)
  public init()
}
final public class IBANValidator : Elements.Validator {
  public init()
  final public func isValid(_ value: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public enum AwaitPaymentMethod : Swift.String, Swift.Decodable {
  case mbway
  case blik
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct AwaitAction : Swift.Decodable {
  public let paymentMethodType: Elements.AwaitPaymentMethod
  public let paymentData: Swift.String
  public init(paymentData: Swift.String, paymentMethodType: Elements.AwaitPaymentMethod)
  public init(from decoder: Swift.Decoder) throws
}
@objc final public class ListItemView : UIKit.UIView, Elements.AnyFormItemView {
  final public var childItemViews: [Elements.AnyFormItemView]
  @objc dynamic public init()
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@_inheritsConvenienceInitializers open class FormValueItemView<ValueType, Style, ItemType> : Elements.FormItemView<ItemType>, Elements.AnyFormValueItemView where ValueType : Swift.Equatable, Style : Elements.FormValueItemStyle, ItemType : Elements.FormValueItem<ValueType, Style> {
  public var titleLabel: UIKit.UILabel {
    get
    set
  }
  required public init(item: ItemType)
  @objc override dynamic open func didAddSubview(_ subview: UIKit.UIView)
  open var isEditing: Swift.Bool {
    get
    set
  }
  open func validate()
  public var showsSeparator: Swift.Bool {
    get
    set
  }
  open func configureSeparatorView()
  @objc deinit
}
public protocol AnyFormValueItemView : Elements.AnyFormItemView {
  var isEditing: Swift.Bool { get set }
  func validate()
}
open class AbstractPersonalInformationComponent : Elements.PaymentComponent, Elements.PresentableComponent, Elements.Localizable {
  final public let paymentMethod: Elements.PaymentMethod
  weak public var delegate: Elements.PaymentComponentDelegate?
  public var viewController: UIKit.UIViewController {
    get
    set
  }
  public var localizationParameters: Elements.LocalizationParameters?
  final public let style: Elements.FormComponentStyle
  final public let requiresModalPresentation: Swift.Bool
  final public let configuration: Elements.AbstractPersonalInformationComponent.Configuration
  public init(paymentMethod: Elements.PaymentMethod, configuration: Elements.AbstractPersonalInformationComponent.Configuration, style: Elements.FormComponentStyle = FormComponentStyle())
  public var firstNameItem: Elements.FormTextInputItem? {
    get
  }
  public var lastNameItem: Elements.FormTextInputItem? {
    get
  }
  public var emailItem: Elements.FormTextInputItem? {
    get
  }
  public var phoneItem: Elements.FormPhoneNumberItem? {
    get
  }
  open func submitButtonTitle() -> Swift.String
  open func createPaymentDetails() -> Elements.PaymentMethodDetails
  open func getPhoneExtensions() -> [Elements.PhoneExtension]
  @objc deinit
}
public struct CardPaymentMethod : Elements.AnyCardPaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public let cardData: [Elements.SupportedCardData]
  public init(from decoder: Swift.Decoder) throws
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(type: Swift.String, name: Swift.String, fundingSource: Elements.CardFundingSource?, cardData: [Elements.SupportedCardData])
}
public struct StoredCardPaymentMethod : Elements.StoredPaymentMethod, Elements.AnyCardPaymentMethod {
  public let type: Swift.String
  public let identifier: Swift.String
  public let name: Swift.String
  public var cardData: [Elements.SupportedCardData] {
    get
  }
  public var fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public let brand: Swift.String
  public let lastFour: Swift.String
  public let expiryMonth: Swift.String
  public let expiryYear: Swift.String
  public let holderName: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public enum ThemeType {
  case light
  case dark
  public static func == (a: Elements.ThemeType, b: Elements.ThemeType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ElementsTheme : Elements.Theme {
  final public let type: Elements.ThemeType
  final public let identifier: Swift.String
  final public var uiPaddingUnit: CoreGraphics.CGFloat
  final public var themeChangeAnimDuration: Swift.Double
  final public let defaultInteractionAnimationDuration: Swift.Double
  final public let screenWidth: CoreGraphics.CGFloat
  final public let screenHeight: CoreGraphics.CGFloat
  final public var colors: Elements.ColorSchema
  final public var fonts: Elements.FontSchema
  final public var images: Elements.ImageAssets
  public static let light: Elements.ElementsTheme
  public static let dark: Elements.ElementsTheme
  public static let variants: [Elements.ElementsTheme]
  public static let manager: Elements.ThemeManager<Elements.ElementsTheme>
  public init(identifier: Swift.String, type: Elements.ThemeType, colors: Elements.ColorSchema = LightThemeColors(), fonts: Elements.FontSchema = LightThemeFonts(), images: Elements.ImageAssets = LightThemeAssets())
  @objc deinit
}
public enum AppTheme {
  public static var current: Elements.ElementsTheme {
    get
  }
}
extension UIProgressView {
  convenience public init(style: Elements.ProgressViewStyle)
}
public protocol DeviceDependant {
  static func isDeviceSupported() -> Swift.Bool
}
public protocol Details : Swift.Encodable {
}
extension Details {
  public var encodable: Elements.AnyEncodable {
    get
  }
}
public protocol PaymentMethodDetails : Elements.Details {
}
public protocol AdditionalDetails : Elements.Details {
}
extension Details {
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
}
public struct CountryCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct ProgressViewStyle : Elements.ViewStyle {
  public let progressTintColor: UIKit.UIColor
  public let trackTintColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public init(progressTintColor: UIKit.UIColor, trackTintColor: UIKit.UIColor)
}
public protocol AnyRetryAPIClient : Elements.APIClientProtocol {
  typealias ShouldRetryHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Bool
  func perform<R>(_ request: R, shouldRetry: Self.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class RetryAPIClient : Elements.AnyRetryAPIClient {
  public init(apiClient: Elements.APIClientProtocol, scheduler: Elements.Scheduler)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  final public func perform<R>(_ request: R, shouldRetry: Elements.RetryAPIClient.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
public protocol FormItemInjector {
  func inject(into formViewController: Elements.FormViewController)
}
final public class FormErrorItem : Elements.FormItem, Elements.Hidable {
  @Elements.Observable @_projectedValueProperty($message) final public var message: Swift.String? {
    get
    set
    _modify
  }
  final public var $message: Elements.Observable<Swift.String?> {
    get
  }
  final public let iconName: Swift.String
  final public let style: Elements.FormErrorItemStyle
  final public var identifier: Swift.String?
  final public var isHidden: Elements.Observable<Swift.Bool>
  final public var subitems: [Elements.FormItem]
  public init(message: Swift.String? = nil, iconName: Swift.String, style: Elements.FormErrorItemStyle = FormErrorItemStyle())
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_inheritsConvenienceInitializers open class BaseFormPickerItemView<T> : Elements.FormValueItemView<Elements.BasePickerElement<T>, Elements.FormTextItemStyle, Elements.BaseFormPickerItem<T>>, UIKit.UIPickerViewDelegate, UIKit.UIPickerViewDataSource where T : Swift.CustomStringConvertible, T : Swift.Equatable {
  required public init(item: Elements.BaseFormPickerItem<T>)
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, titleForRow row: Swift.Int, forComponent component: Swift.Int) -> Swift.String?
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent component: Swift.Int)
  @objc deinit
}
public enum ComponentError : Swift.Error {
  case cancelled
  case paymentMethodNotSupported
  public static func == (a: Elements.ComponentError, b: Elements.ComponentError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Analytics {
  public enum Flavor : Swift.String {
    case components, dropin
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Event {
    public var component: Swift.String
    public var flavor: Elements.Analytics.Flavor
    public var environment: Elements.Environment
    public init(component: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  }
  public static var isEnabled: Swift.Bool
  public static func sendEvent(component: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  @objc deinit
}
final public class ThemeManager<T> where T : Elements.Theme {
  final public var observers: Foundation.NSHashTable<Swift.AnyObject>
  final public var activeTheme: T {
    get
    set
  }
  public init(default theme: T, persistor: Elements.ThemePersistor = UserDefaults.standard, forceDefault: Swift.Bool = false)
  @objc deinit
}
public enum CancelButtonStyle {
  case system
  case legacy
  case custom(UIKit.UIImage)
}
public enum ToolbarMode {
  case leftCancel
  case rightCancel
  case natural
  public static func == (a: Elements.ToolbarMode, b: Elements.ToolbarMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct NavigationStyle {
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public var tintColor: UIKit.UIColor?
  public var cornerRadius: CoreGraphics.CGFloat
  public var barTitle: Elements.TextStyle
  public var cancelButton: Elements.CancelButtonStyle
  public var toolbarMode: Elements.ToolbarMode
  public init()
}
final public class FormSplitItem : Elements.FormItem {
  final public let style: Elements.ViewStyle
  final public var identifier: Swift.String?
  final public var subitems: [Elements.FormItem] {
    get
  }
  public init(items: Elements.FormItem..., style: Elements.ViewStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_hasMissingDesignatedInitializers open class FormTextItem : Elements.FormValueItem<Swift.String, Elements.FormTextItemStyle>, Elements.ValidatableFormItem, Elements.InputViewRequiringFormItem {
  @Elements.Observable @_projectedValueProperty($placeholder) public var placeholder: Swift.String? {
    get
    set
    _modify
  }
  public var $placeholder: Elements.Observable<Swift.String?> {
    get
  }
  public var formatter: Elements.Formatter?
  public var validator: Elements.Validator?
  public var validationFailureMessage: Swift.String?
  public var autocapitalizationType: UIKit.UITextAutocapitalizationType
  public var autocorrectionType: UIKit.UITextAutocorrectionType
  public var keyboardType: UIKit.UIKeyboardType
  public var contentType: UIKit.UITextContentType?
  public init(style: Elements.FormTextItemStyle)
  public func isValid() -> Swift.Bool
  @objc deinit
}
public protocol Scheduler {
  func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public protocol ViewStyle {
  var backgroundColor: UIKit.UIColor { get set }
}
public protocol TintableStyle : Elements.ViewStyle {
  var tintColor: UIKit.UIColor? { get set }
}
@_inheritsConvenienceInitializers final public class FormTextInputItemView : Elements.FormTextItemView<Elements.FormTextInputItem> {
  required public init(item: Elements.FormTextInputItem)
  @objc deinit
}
@objc public protocol STPFormEncodable : ObjectiveC.NSObjectProtocol {
  @objc static func rootObjectName() -> Swift.String?
  @objc static func propertyNamesToFormFieldNamesMapping() -> [Swift.String : Swift.String]
  @objc var additionalAPIParameters: [Swift.AnyHashable : Any] { get set }
}
public protocol ElementsAPIClientType : AnyObject {
  func tokenizeCard(data: Elements.ElementsCardParams, completion: @escaping (Swift.Result<Elements.VaultToken, Swift.Error>) -> Swift.Void)
  func performPaymentsSetup(data: Elements.PaymentComponentData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
}
public class ElementsAPIClientConfiguration {
  final public let environment: Elements.Environment
  final public let stripePublishableKey: Swift.String?
  public init(environment: Elements.Environment, stripePublishableKey: Swift.String? = nil)
  @objc deinit
}
public class ElementsAPIClient : Elements.ElementsAPIClientType {
  public init(config: Elements.ElementsAPIClientConfiguration)
  public func tokenizeCard(data: Elements.ElementsCardParams, completion: @escaping (Swift.Result<Elements.VaultToken, Swift.Error>) -> Swift.Void)
  public func performPaymentsSetup(data: Elements.PaymentComponentData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension ElementsScope where Base : UIKit.UIView {
  public func round(corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, precentage: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, rounding: Elements.CornerRounding)
  public func round(using rounding: Elements.CornerRounding)
}
public struct APIError : Swift.Decodable, Swift.Error, Foundation.LocalizedError {
  public let status: Swift.Int?
  public let errorCode: Swift.String
  public let errorMessage: Swift.String
  public let type: Elements.APIErrorType
  public var errorDescription: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum APIErrorType : Swift.String, Swift.Decodable {
  case `internal`
  case validation
  case security
  case configuration
  case urlError
  case noInternet
  case sessionExpired
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UILabel {
  convenience public init(style: Elements.TextStyle)
}
public protocol ThemePersistor {
  func retreiveThemeId() -> Swift.String?
  func saveThemeId(_ identifier: Swift.String)
}
extension UserDefaults : Elements.ThemePersistor {
  public func retreiveThemeId() -> Swift.String?
  public func saveThemeId(_ identifier: Swift.String)
}
final public class FormPhoneNumberItem : Elements.FormTextItem {
  final public var prefix: Swift.String {
    get
  }
  final public var phoneNumber: Swift.String {
    get
  }
  public init(selectableValues: [Elements.PhoneExtensionPickerItem], style: Elements.FormTextItemStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  override public init(style: Elements.FormTextItemStyle)
  @objc deinit
}
extension URL {
  public var queryParameters: [Swift.String : Swift.String] {
    get
  }
  public var isHttp: Swift.Bool {
    get
  }
}
public struct Payment {
  public struct Amount {
    public var value: Swift.Int
    public var currencyCode: Swift.String
    public init(value: Swift.Int, currencyCode: Swift.String)
    public init(value: Foundation.Decimal, currencyCode: Swift.String)
  }
  public var amount: Elements.Payment.Amount
  public var countryCode: Swift.String?
  public init(amount: Elements.Payment.Amount, countryCode: Swift.String? = nil)
}
extension Payment.Amount {
  public var formatted: Swift.String {
    get
  }
}
public protocol PickerElement : Swift.CustomStringConvertible, Swift.Equatable {
  var identifier: Swift.String { get }
}
public struct BasePickerElement<ElementType> : Elements.PickerElement where ElementType : Swift.CustomStringConvertible {
  public let identifier: Swift.String
  public let element: ElementType
  public static func == (lhs: Elements.BasePickerElement<ElementType>, rhs: Elements.BasePickerElement<ElementType>) -> Swift.Bool
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class BaseFormPickerItem<ElementType> : Elements.FormValueItem<Elements.BasePickerElement<ElementType>, Elements.FormTextItemStyle>, Elements.InputViewRequiringFormItem where ElementType : Swift.CustomStringConvertible {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class ListCell : UIKit.UITableViewCell {
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc deinit
}
public struct IssuerListPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let issuers: [Elements.IssuerListPaymentMethod.Issuer]
  public struct Issuer : Swift.Decodable {
    public let identifier: Swift.String
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
}
public enum VaultToken {
  case elements(token: Swift.String)
  case stripe(token: Elements.StripeVaultToken)
}
public struct TokenizationResponse : Elements.Response {
  public let token: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
final public class IBANFormatter : Elements.Formatter {
  public init()
  final public func formattedValue(for value: Swift.String) -> Swift.String
  final public func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol Localizable {
  var localizationParameters: Elements.LocalizationParameters? { get set }
}
public protocol Cancellable : AnyObject {
  func didCancel()
}
public protocol PresentableComponent : Elements.Component {
  var requiresModalPresentation: Swift.Bool { get }
  var viewController: UIKit.UIViewController { get }
}
extension PresentableComponent {
  public var requiresModalPresentation: Swift.Bool {
    get
  }
}
public protocol TrackableComponent : Elements.Component, Elements.PaymentMethodAware, Elements.ViewControllerDelegate {
}
extension TrackableComponent {
  public func viewDidLoad(viewController: UIKit.UIViewController)
  public func viewDidAppear(viewController: UIKit.UIViewController)
}
open class LengthValidator : Elements.Validator {
  open var minimumLength: Swift.Int?
  open var maximumLength: Swift.Int?
  public init(minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  open func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
  @objc deinit
}
public struct RedirectPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(type: Swift.String, name: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
public struct StoredRedirectPaymentMethod : Elements.StoredPaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let identifier: Swift.String
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(from decoder: Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers final public class SecuredViewController : UIKit.UIViewController {
  weak final public var delegate: Elements.ViewControllerDelegate?
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc override final public var title: Swift.String? {
    @objc get
    @objc set
  }
  public init(child: UIKit.UIViewController, style: Elements.ViewStyle)
  @objc deinit
  @objc override final public func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public struct StoredPayPalPaymentMethod : Elements.StoredPaymentMethod {
  public let type: Swift.String
  public let identifier: Swift.String
  public let name: Swift.String
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  public let emailAddress: Swift.String
  public func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
  public init(from decoder: Swift.Decoder) throws
}
public struct UnknownError : Swift.Error, Foundation.LocalizedError {
  public var errorDescription: Swift.String?
  public init(errorDescription: Swift.String? = nil)
}
public struct ThreeDS2ChallengeAction : Swift.Decodable {
  public let challengeToken: Swift.String
  public let authorisationToken: Swift.String?
  public let paymentData: Swift.String?
  public init(challengeToken: Swift.String, authorisationToken: Swift.String? = nil, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
public protocol PaymentMethod : Swift.Decodable {
  var type: Swift.String { get }
  var name: Swift.String { get }
  var displayInformation: Elements.DisplayInformation { get }
  func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  func buildComponent(using builder: Elements.PaymentComponentBuilder) -> Elements.PaymentComponent?
}
public struct DisplayInformation {
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var logoName: Swift.String
}
extension DisplayInformation : Swift.Equatable {
  public static func == (a: Elements.DisplayInformation, b: Elements.DisplayInformation) -> Swift.Bool
}
extension PaymentMethod {
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using _: Elements.LocalizationParameters?) -> Elements.DisplayInformation
}
public protocol StoredPaymentMethod : Elements.PaymentMethod {
  var identifier: Swift.String { get }
  var supportedShopperInteractions: [Elements.ShopperInteraction] { get }
}
@objc @_hasMissingDesignatedInitializers final public class CopyLabelView : UIKit.UIView, Elements.Localizable {
  final public var localizationParameters: Elements.LocalizationParameters?
  public init(text: Swift.String, style: Elements.TextStyle)
  @objc deinit
  @objc override final public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override final public func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
final public class StripeAPIClient {
  public typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  public init(publishableKey: Swift.String, stripeAccount: Swift.String?)
  final public func perform<R>(_ request: R, parameters: [Swift.String : Any], completionHandler: @escaping Elements.StripeAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@objc public class STPAppInfo : ObjectiveC.NSObject {
  public init(name: Swift.String, partnerId: Swift.String?, version: Swift.String?, url: Swift.String?)
  public var name: Swift.String {
    get
  }
  public var partnerId: Swift.String? {
    get
  }
  public var version: Swift.String? {
    get
  }
  public var url: Swift.String? {
    get
  }
  @objc deinit
  @objc override dynamic public init()
}
public struct PaymentSetupModel : Swift.Codable {
  public let returnURL: Swift.String
  public let cancelURL: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PaymentsSetupRequest : Elements.Request {
  public typealias ResponseType = Elements.PaymentsResponse
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
  public init(data: Elements.PaymentComponentData, encodedToken: Swift.String?)
}
public struct BrowserInfo : Swift.Encodable {
  public var userAgent: Swift.String? {
    get
  }
  public static func initialize(completion: @escaping ((Elements.BrowserInfo?) -> Swift.Void))
  public func encode(to encoder: Swift.Encoder) throws
}
extension ElementsScope where Base : UIKit.UIView {
  @discardableResult
  public func anchore(inside view: UIKit.UIView, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func anchore(inside margines: UIKit.UILayoutGuide, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  public func wrapped(with insets: UIKit.UIEdgeInsets = .zero) -> UIKit.UIView
}
public struct Environment : Elements.APIEnvironment {
  public var baseURL: Foundation.URL
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public var queryParameters: [Foundation.URLQueryItem]
  public let clientKey: Swift.String
  public static func sandbox(clientKey: Swift.String) -> Elements.Environment
  public static func portForward(clientKey: Swift.String) -> Elements.Environment
  public static func production(clientKey: Swift.String) -> Elements.Environment
  public static let unknown: Elements.Environment
  public init(baseURL: Foundation.URL? = nil, clientKey: Swift.String)
}
public struct SupportedCardData : Swift.Decodable {
  public let brand: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case brand
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(from decoder: Swift.Decoder) throws
}
extension String : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.String
}
extension Optional : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Optional<Wrapped>
}
extension ElementsScope where Base == Swift.String? {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
extension ElementsScope where Base == Swift.String {
  public var nilIfEmpty: Swift.String? {
    get
  }
  public func truncate(to length: Swift.Int) -> Swift.String
  public func components(withLengths lengths: [Swift.Int]) -> [Swift.String]
  public func components(withLength length: Swift.Int) -> [Swift.String]
  public subscript(position: Swift.Int) -> Swift.String {
    get
  }
  public subscript(range: Swift.Range<Swift.Int>) -> Swift.String {
    get
  }
  public subscript(range: Swift.ClosedRange<Swift.Int>) -> Swift.String {
    get
  }
}
public struct IBANSpecification {
  public static let highestMaximumLength: Swift.Int
  public let countryCode: Swift.String
  public let length: Swift.Int
  public let structure: Swift.String
  public let example: Swift.String
  public init?(forCountryCode countryCode: Swift.String)
}
public struct FormSwitchItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var tintColor: UIKit.UIColor?
  public var separatorColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
public enum Coder {
  public static func decode<T>(_ data: Foundation.Data) throws -> T where T : Swift.Decodable
  public static func decode<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func decodeBase64<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  public static func encode<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
  public static func encodeBase64<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
}
public enum CornerRounding {
  case none
  case fixed(CoreGraphics.CGFloat)
  case percent(CoreGraphics.CGFloat)
}
extension CornerRounding : Swift.Equatable {
  public static func == (lhs: Elements.CornerRounding, rhs: Elements.CornerRounding) -> Swift.Bool
}
public protocol EventPublisher : AnyObject {
  associatedtype Event
  var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Self.Event>] { get set }
}
extension EventPublisher {
  public func addEventHandler(_ eventHandler: @escaping Elements.EventHandler<Self.Event>) -> Elements.EventHandlerToken
  public func removeEventHandler(with token: Elements.EventHandlerToken)
  public func publish(_ event: Self.Event)
}
public typealias EventHandler<Event> = (Event) -> Swift.Void
public struct EventHandlerToken : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Elements.EventHandlerToken, b: Elements.EventHandlerToken) -> Swift.Bool
}
public struct StripeVaultToken : Elements.Response {
  public let id: Swift.String
  public let type: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
extension Elements.BillingAddressFields : Swift.Equatable {}
extension Elements.BillingAddressFields : Swift.Hashable {}
extension Elements.BillingAddressFields : Swift.RawRepresentable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Equatable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Hashable {}
extension Elements.CardFundingSource : Swift.Equatable {}
extension Elements.CardFundingSource : Swift.Hashable {}
extension Elements.CardFundingSource : Swift.RawRepresentable {}
extension Elements.ThreeDS2Action.ActionType : Swift.Equatable {}
extension Elements.ThreeDS2Action.ActionType : Swift.Hashable {}
extension Elements.ThreeDS2Action.ActionType : Swift.RawRepresentable {}
extension Elements.ShopperInteraction : Swift.Equatable {}
extension Elements.ShopperInteraction : Swift.Hashable {}
extension Elements.ShopperInteraction : Swift.RawRepresentable {}
extension Elements.AppImageName : Swift.Equatable {}
extension Elements.AppImageName : Swift.Hashable {}
extension Elements.AppImageName : Swift.RawRepresentable {}
extension Elements.HTTPMethod : Swift.Equatable {}
extension Elements.HTTPMethod : Swift.Hashable {}
extension Elements.HTTPMethod : Swift.RawRepresentable {}
extension Elements.LogoURLProvider.Size : Swift.Equatable {}
extension Elements.LogoURLProvider.Size : Swift.Hashable {}
extension Elements.LogoURLProvider.Size : Swift.RawRepresentable {}
extension Elements.AwaitPaymentMethod : Swift.Equatable {}
extension Elements.AwaitPaymentMethod : Swift.Hashable {}
extension Elements.AwaitPaymentMethod : Swift.RawRepresentable {}
extension Elements.ThemeType : Swift.Equatable {}
extension Elements.ThemeType : Swift.Hashable {}
extension Elements.ComponentError : Swift.Equatable {}
extension Elements.ComponentError : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.Equatable {}
extension Elements.Analytics.Flavor : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.RawRepresentable {}
extension Elements.ToolbarMode : Swift.Equatable {}
extension Elements.ToolbarMode : Swift.Hashable {}
extension Elements.APIErrorType : Swift.Equatable {}
extension Elements.APIErrorType : Swift.Hashable {}
extension Elements.APIErrorType : Swift.RawRepresentable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Equatable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Hashable {}
extension Elements.SupportedCardData.CodingKeys : Swift.RawRepresentable {}
