// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Elements
import AVKit
import Accelerate
import CommonCrypto
import CoreGraphics
import CoreImage
import Darwin/*.fputs*/
@_exported import Elements
import Elements3DS2
import ElementsListKit
import Foundation
import ImageIO
import MobileCoreServices
import PassKit
import SafariServices
import Swift
import UIKit
import WebKit
public struct PaymentsResponse : Elements.Response {
  public let action: Elements.Action?
  public let token: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public protocol BillingAddressInformation {
  var billingAddress: Elements.AddressInfo? { get }
}
public struct PaymentElementData {
  public let paymentMethod: Elements.PaymentMethodDetails?
  public let storePaymentMethod: Swift.Bool
  public let browserInfo: Elements.BrowserInfo?
  public var billingAddress: Elements.AddressInfo? {
    get
  }
  public init(paymentMethodDetails: Elements.PaymentMethodDetails?, storePaymentMethod: Swift.Bool = false, browserInfo: Elements.BrowserInfo? = nil)
  public func dataByAddingBrowserInfo(completion: @escaping ((Elements.PaymentElementData) -> Swift.Void))
}
public struct CurrencyCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct AddressStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor? {
    get
  }
}
extension Array {
  public mutating func removeElementByReference(_ element: Element)
}
@objc public class ApplePayElement : ObjectiveC.NSObject, Elements.PresentableElement, Elements.PaymentElement, Elements.Localizable, Elements.FinalizableElement {
  public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak public var delegate: Elements.PaymentElementDelegate?
  public init(configuration: Elements.ApplePayElement.Configuration) throws
  public var viewController: UIKit.UIViewController {
    get
  }
  public var localizationParameters: Elements.LocalizationParameters?
  public func didFinalize(with success: Swift.Bool)
  @objc deinit
  @objc override dynamic public init()
}
extension ApplePayElement {
  public enum Error : Swift.Error, Foundation.LocalizedError {
    case userCannotMakePayment
    case deviceDoesNotSupportApplyPay
    case emptySummaryItems
    case negativeGrandTotal
    case invalidSummaryItem
    case invalidCountryCode
    case invalidCurrencyCode
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: Elements.ApplePayElement.Error, b: Elements.ApplePayElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension DropInElement {
  public struct Style {
    public var navigation: Elements.NavigationStyle
    public var listElement: Elements.ListElementStyle
    public var formElement: Elements.FormElementStyle
    public var redirectElement: Elements.RedirectElementStyle?
    public var separatorColor: UIKit.UIColor? {
      get
      set
    }
    public init()
    public init(tintColor: UIKit.UIColor)
  }
}
public protocol ElementLoader : Elements.LoadingElement {
  func startLoading(for element: Elements.PaymentElement)
}
public protocol LoadingElement {
  func stopLoading()
}
public protocol Element : AnyObject {
  var environment: Elements.Environment { get set }
}
extension Element {
  public func finalizeIfNeeded(with success: Swift.Bool)
  public func cancelIfNeeded()
  public func stopLoadingIfNeeded()
}
public protocol FinalizableElement : Elements.Element {
  func didFinalize(with success: Swift.Bool)
}
extension Element {
  public var environment: Elements.Environment {
    get
    set
  }
  public var _isDropIn: Swift.Bool {
    get
    set
  }
}
public protocol DismissableElement : Elements.Element {
  func dismiss(_ animated: Swift.Bool, completion: (() -> Swift.Void)?)
}
public typealias KeyboardInfo = (option: UIKit.UIView.AnimationOptions, keyboardHeight: CoreGraphics.CGFloat, duration: Swift.Double)
public enum KeyboardState {
  case hide
  case show
  public static func == (a: Elements.KeyboardState, b: Elements.KeyboardState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum BaseViewControllerStyle {
  case withCustomNavBar
  case nativeNavBar
  public static func == (a: Elements.BaseViewControllerStyle, b: Elements.BaseViewControllerStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc open class BaseViewController : UIKit.UIViewController {
  public var keyboardState: Elements.KeyboardState
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc dynamic public init()
  @objc required convenience dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidLayoutSubviews()
  @objc open func adjustViewWhenKeyboardShow(notification: Foundation.NSNotification)
  @objc open func adjustViewWhenKeyboardDismiss(notification: Foundation.NSNotification)
  open func presentErrorAlertView(title: Swift.String, message: Swift.String, completion: (() -> Swift.Void)? = nil)
  open func showNetworkRequestError(message: Swift.String?)
  open func showNetworkSuccess(message: Swift.String?)
  open func hideMessageErrorView()
  open func showLoadingView()
  open func hideLoadingView(completion: Elements.VoidCompletion?)
  open func showInViewLoading()
  open func hideInViewLoading(completion: Elements.VoidCompletion?)
  public func presentNetworkSuccess(message: Swift.String?)
  public func presentNetworkRequestError(message: Swift.String?)
  public func dismissMessageErrorView()
  public func presentLoadingView()
  public func dismissLoadingView(completion: Elements.VoidCompletion?)
  public func presentInViewLoading()
  public func dismissInViewLoading(completion: Elements.VoidCompletion?)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension BaseViewController {
  open func obtainKeyboardInfo(from notification: Foundation.NSNotification) -> Elements.KeyboardInfo?
  open func addKeyboardNotifications()
  open func removeKeyboardNotifications()
}
final public class ElementsPay {
  final public let configuration: Elements.Blocks.Configuration
  required public init(configuration: Elements.Blocks.Configuration)
  @_hasMissingDesignatedInitializers final public class DropIn {
    public static func create(configuration: Elements.Blocks.Configuration, completion: @escaping (Swift.Result<Elements.DropInElement, Swift.Error>) -> Swift.Void)
    @objc deinit
  }
  @objc deinit
}
final public class RedirectElement : Elements.ActionElement {
  public enum Error : Swift.Error {
    case appNotFound
    public static func == (a: Elements.RedirectElement.Error, b: Elements.RedirectElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  weak final public var delegate: Elements.ActionElementDelegate?
  weak final public var presentationDelegate: Elements.PresentationDelegate?
  public init(style: Elements.RedirectElementStyle? = nil)
  final public func handle(_ action: Elements.RedirectAction)
  @discardableResult
  public static func applicationDidOpen(from url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
extension RedirectElement : Elements.ActionElementDelegate {
  final public func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  final public func didComplete(from element: Elements.ActionElement)
  final public func didFail(with error: Swift.Error, from element: Elements.ActionElement)
  final public func didOpenExternalApplication(_ element: Elements.ActionElement)
}
public enum BillingAddressFields : Swift.UInt {
  case none
  case postalCode
  case full
  case name
  public typealias RawValue = Swift.UInt
  public init?(rawValue: Swift.UInt)
  public var rawValue: Swift.UInt {
    get
  }
}
public class AddressParams : Swift.Codable {
  public var name: Swift.String?
  public var line1: Swift.String?
  public var line2: Swift.String?
  public var city: Swift.String?
  public var state: Swift.String?
  public var postalCode: Swift.String?
  public var country: Swift.String?
  public var phone: Swift.String?
  public var email: Swift.String?
  public init()
  public init(pkContact contact: PassKit.PKContact)
  public func pkContactValue() -> PassKit.PKContact
  public init(cnContact contact: Contacts.CNContact)
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CreatePaymentMethodResponse : Elements.Response {
  public let token: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class FontPlate {
  @objc deinit
}
public protocol FontSchema {
  var primaryTextFont: UIKit.UIFont { get }
  var boldPrimaryTextFont: UIKit.UIFont { get }
  var secondaryTextFont: UIKit.UIFont { get }
  var boldSecondaryTextFont: UIKit.UIFont { get }
  var smallTextFont: UIKit.UIFont { get }
  var largeTextFont: UIKit.UIFont { get }
  var boldLargeTextFont: UIKit.UIFont { get }
}
final public class LightThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
final public class DarkThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
public protocol FormTextItemViewDelegate : AnyObject {
  func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
public protocol AnyFormTextItemView : Elements.AnyFormItemView {
  var delegate: Elements.FormTextItemViewDelegate? { get set }
}
@_inheritsConvenienceInitializers open class FormTextItemView<ItemType> : Elements.FormValueItemView<Swift.String, Elements.FormTextItemStyle, ItemType>, UIKit.UITextFieldDelegate, Elements.AnyFormTextItemView where ItemType : Elements.FormTextItem {
  required public init(item: ItemType)
  weak public var delegate: Elements.FormTextItemViewDelegate?
  public var textField: UIKit.UITextField {
    get
    set
  }
  public var accessory: Elements.FormTextItemView<ItemType>.AccessoryType {
    get
    set
  }
  override public func validate()
  override open func configureSeparatorView()
  @objc override dynamic open var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    @objc get
  }
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @objc public func textFieldShouldReturn(_: UIKit.UITextField) -> Swift.Bool
  @objc open func textFieldDidEndEditing(_: UIKit.UITextField)
  @objc open func textFieldDidBeginEditing(_: UIKit.UITextField)
  open func updateValidationStatus(forced: Swift.Bool = false)
  @objc deinit
}
extension FormTextItemView {
  public enum AccessoryType : Swift.Equatable {
    case invalid
    case valid
    case customView(UIKit.UIView)
    case none
    public static func == (a: Elements.FormTextItemView<ItemType>.AccessoryType, b: Elements.FormTextItemView<ItemType>.AccessoryType) -> Swift.Bool
  }
}
public struct StripeTokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.StripeVaultToken
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListItemsSection {
  public var title: Swift.String?
  public var items: [Elements.ListItem]
  public init(title: Swift.String? = nil, items: [Elements.ListItem])
}
public protocol ViewControllerDelegate : AnyObject {
  func viewDidLoad(viewController: UIKit.UIViewController)
  func viewDidAppear(viewController: UIKit.UIViewController)
}
public struct ChargeData : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol Theme : Swift.Equatable {
  var identifier: Swift.String { get }
  static var variants: [Self] { get }
  static var manager: Elements.ThemeManager<Self> { get }
  var colors: Elements.ColorSchema { get set }
  var fonts: Elements.FontSchema { get set }
  var images: Elements.ImageAssets { get set }
}
extension Theme {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class FullFormAddressItem : Elements.FormValueItem<Elements.AddressInfo, Elements.AddressStyle>, Elements.Observer {
  override final public var subitems: [Elements.FormItem] {
    get
  }
  public init(initialCountry: Swift.String, style: Elements.AddressStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSSelectionCustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSSelectionCustomization
  @objc public var primarySelectedColor: UIKit.UIColor {
    @objc get
    @objc set(primarySelectedColor)
  }
  @objc public var secondarySelectedColor: UIKit.UIColor {
    @objc get
    @objc set(secondarySelectedColor)
  }
  @objc public var unselectedBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set(unselectedBackgroundColor)
  }
  @objc public var unselectedBorderColor: UIKit.UIColor {
    @objc get
    @objc set(unselectedBorderColor)
  }
  @objc deinit
  @objc override dynamic public init()
}
public enum ElementsLogging {
  public static var isEnabled: Swift.Bool
}
public func elementsPrint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
@_hasMissingDesignatedInitializers final public class AmountFormatter {
  public static func formatted(amount: Swift.Int, currencyCode: Swift.String) -> Swift.String?
  public static func minorUnitAmount(from majorUnitAmount: Swift.Double, currencyCode: Swift.String) -> Swift.Int
  public static func minorUnitAmount(from majorUnitAmount: Foundation.Decimal, currencyCode: Swift.String) -> Swift.Int
  @objc deinit
}
public class RegularExpressionValidator : Elements.LengthValidator {
  public init(regularExpression: Swift.String, minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  override public func maximumLength(for _: Swift.String) -> Swift.Int
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class NetworkImageView : UIKit.UIImageView {
  public var imageURL: Foundation.URL? {
    get
    set
  }
  @objc override dynamic open func didMoveToWindow()
  @objc deinit
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol InteractorScope : AnyObject {
  var isActive: Swift.Bool { get }
}
public protocol Interactable : Elements.InteractorScope {
  func activate()
  func deactivate()
}
open class Interactor : Elements.Interactable {
  public var isActive: Swift.Bool
  public init()
  final public func activate()
  open func didBecomeActive()
  final public func deactivate()
  open func willResignActive()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class ContainerView : UIKit.UIView {
  public init(body: UIKit.UIView, padding: UIKit.UIEdgeInsets = .zero)
  final public func setupConstraints()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension CardElement {
  public enum AddressFormType {
    case full
    case postalCode
    case none
    public static func == (a: Elements.CardElement.AddressFormType, b: Elements.CardElement.AddressFormType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Configuration {
    public var showsHolderNameField: Swift.Bool
    public var showsStorePaymentMethodField: Swift.Bool
    public var showsSecurityCodeField: Swift.Bool
    public var billingAddressMode: Elements.CardElement.AddressFormType
    public var stored: Elements.StoredCardConfiguration
    public var allowedCardTypes: [Elements.CardType]?
    public init(showsHolderNameField: Swift.Bool = false, showsStorePaymentMethodField: Swift.Bool = true, showsSecurityCodeField: Swift.Bool = true, billingAddressMode: Elements.CardElement.AddressFormType = .none, storedCardConfiguration: Elements.StoredCardConfiguration = StoredCardConfiguration(), allowedCardTypes: [Elements.CardType]? = nil)
  }
}
extension AbstractPersonalInformationElement : Elements.LoadingElement, Elements.TrackableElement {
  public func stopLoading()
}
public enum PersonalInformation : Swift.Equatable {
  case firstName
  case lastName
  case email
  case phone
  case custom(Elements.FormItemInjector)
  public static func == (lhs: Elements.PersonalInformation, rhs: Elements.PersonalInformation) -> Swift.Bool
}
extension AbstractPersonalInformationElement {
  public struct Configuration {
    public let fields: [Elements.PersonalInformation]
    public init(fields: [Elements.PersonalInformation])
  }
}
public protocol ParameterlessInitializable {
  init()
}
extension ElementsScope where Base : UIKit.UIView {
  public func snapShot() -> UIKit.UIImage?
  public func hideWithAnimation(_ hidden: Swift.Bool)
}
public struct EmptyPaymentDetails : Elements.PaymentMethodDetails {
  public let type: Swift.String
  public init(type: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListPaymentMethodsResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers open class BaseListViewController : Elements.BaseViewController {
  @objc required convenience dynamic public init?(coder _: Foundation.NSCoder)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @objc override dynamic public init()
}
final public class FormButtonItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let style: Elements.FormButtonItemStyle
  final public var identifier: Swift.String?
  final public var title: Swift.String?
  @Elements.Observable @_projectedValueProperty($showsActivityIndicator) final public var showsActivityIndicator: Swift.Bool {
    get
    set
    _modify
  }
  final public var $showsActivityIndicator: Elements.Observable<Swift.Bool> {
    get
  }
  @Elements.Observable @_projectedValueProperty($enabled) final public var enabled: Swift.Bool {
    get
    set
    _modify
  }
  final public var $enabled: Elements.Observable<Swift.Bool> {
    get
  }
  final public var buttonSelectionHandler: (() -> Swift.Void)?
  public init(style: Elements.FormButtonItemStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
open class Component<DependencyType> : Elements.Dependency {
  final public let dependency: DependencyType
  public init(dependency: DependencyType)
  final public func shared<T>(__function: Swift.String = #function, _ factory: () -> T) -> T
  @objc deinit
}
open class EmptyComponent : Elements.EmptyDependency {
  public init()
  @objc deinit
}
public struct WalletsPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let supportedPaymentMethods: [Elements.PaymentMethod]
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, supportedPaymentMethods: [Elements.PaymentMethod])
}
public class ListItem : Elements.FormItem {
  final public let id: Swift.String
  public var subitems: [Elements.FormItem]
  final public let style: Elements.ListItemStyle
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var imageURL: Foundation.URL?
  public var showsDisclosureIndicator: Swift.Bool
  public var selectionHandler: (() -> Swift.Void)?
  public var identifier: Swift.String?
  final public let canModifyIcon: Swift.Bool
  public init(id: Swift.String, title: Swift.String, imageURL: Foundation.URL? = nil, style: Elements.ListItemStyle = ListItemStyle(), showsDisclosureIndicator: Swift.Bool = true, selectionHandler: (() -> Swift.Void)? = nil, canModifyIcon: Swift.Bool = true)
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension ListItem : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Elements.ListItem, rhs: Elements.ListItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum StoredPaymentMethodType : Swift.String, Swift.Decodable {
  case card
  case paypal
  case kakaoPay
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct StoredPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let identifier: Swift.String
  public let name: Swift.String
  public var fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public let brand: Swift.String?
  public let lastFour: Swift.String
  public let expiryMonth: Swift.String
  public let expiryYear: Swift.String
  public let holderName: Swift.String?
  public let paymentMethodType: Elements.StoredPaymentMethodType
  public let emailAddress: Swift.String?
  public let brandDisplayName: Swift.String?
  public let brandIconURL: Foundation.URL?
  public init(from decoder: Swift.Decoder) throws
  public init(type: Swift.String, name: Swift.String, holderName: Swift.String?, brand: Swift.String?, lastFour: Swift.String, expiryMonth: Swift.String, expiryYear: Swift.String, emailAddress: Swift.String?, brandDisplayName: Swift.String?, brandIconURL: Foundation.URL?, fundingSource: Elements.CardFundingSource)
}
open class FormItemView<ItemType> : UIKit.UIView, Elements.AnyFormItemView, Elements.Observer where ItemType : Elements.FormItem {
  final public let item: ItemType
  required public init(item: ItemType)
  @available(*, unavailable)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  open var childItemViews: [Elements.AnyFormItemView] {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol AnyFormItemView : UIKit.UIView {
  var parentItemView: Elements.AnyFormItemView? { get }
  var childItemViews: [Elements.AnyFormItemView] { get }
}
extension AnyFormItemView {
  public var parentItemView: Elements.AnyFormItemView? {
    get
  }
  public var flatSubitemViews: [Elements.AnyFormItemView] {
    get
  }
}
public struct LocalizationKey {
  public static let submitButton: Elements.LocalizationKey
  public static let submitButtonFormatted: Elements.LocalizationKey
  public static let cancelButton: Elements.LocalizationKey
  public static let dismissButton: Elements.LocalizationKey
  public static let errorTitle: Elements.LocalizationKey
  public static let errorUnknown: Elements.LocalizationKey
  public static let validationAlertTitle: Elements.LocalizationKey
  public static let paymentMethodsOtherMethods: Elements.LocalizationKey
  public static let paymentMethodsTitle: Elements.LocalizationKey
  public static let sepaIbanItemTitle: Elements.LocalizationKey
  public static let sepaIbanItemInvalid: Elements.LocalizationKey
  public static let sepaNameItemTitle: Elements.LocalizationKey
  public static let sepaNameItemPlaceholder: Elements.LocalizationKey
  public static let sepaConsentLabel: Elements.LocalizationKey
  public static let sepaNameItemInvalid: Elements.LocalizationKey
  public static let cardStoreDetailsButton: Elements.LocalizationKey
  public static let cardNameItemTitle: Elements.LocalizationKey
  public static let cardNameItemPlaceholder: Elements.LocalizationKey
  public static let cardNameItemInvalid: Elements.LocalizationKey
  public static let cardNumberItemTitle: Elements.LocalizationKey
  public static let cardNumberItemPlaceholder: Elements.LocalizationKey
  public static let cardNumberItemInvalid: Elements.LocalizationKey
  public static let cardExpiryItemTitle: Elements.LocalizationKey
  public static let cardExpiryItemPlaceholder: Elements.LocalizationKey
  public static let cardExpiryItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemTitle: Elements.LocalizationKey
  public static let cardCvcItemPlaceholder: Elements.LocalizationKey
  public static let cardStoredTitle: Elements.LocalizationKey
  public static let cardStoredMessage: Elements.LocalizationKey
  public static let cardStoredExpires: Elements.LocalizationKey
  public static let dropInStoredTitle: Elements.LocalizationKey
  public static let dropInPreselectedOpenAllTitle: Elements.LocalizationKey
  public static let continueTo: Elements.LocalizationKey
  public static let phoneNumberTitle: Elements.LocalizationKey
  public static let phoneNumberInvalid: Elements.LocalizationKey
  public static let phoneNumberPlaceholder: Elements.LocalizationKey
  public static let cardCvcItemPlaceholderDigits: Elements.LocalizationKey
  public static let emailItemTitle: Elements.LocalizationKey
  public static let emailItemPlaceHolder: Elements.LocalizationKey
  public static let emailItemInvalid: Elements.LocalizationKey
  public static let mbwayConfirmPayment: Elements.LocalizationKey
  public static let awaitWaitForConfirmation: Elements.LocalizationKey
  public static let blikConfirmPayment: Elements.LocalizationKey
  public static let blikInvalid: Elements.LocalizationKey
  public static let blikCode: Elements.LocalizationKey
  public static let blikHelp: Elements.LocalizationKey
  public static let blikPlaceholder: Elements.LocalizationKey
  public static let preauthorizeWith: Elements.LocalizationKey
  public static let confirmPreauthorization: Elements.LocalizationKey
  public static let cardCvcItemTitleOptional: Elements.LocalizationKey
  public static let confirmPurchase: Elements.LocalizationKey
  public static let lastName: Elements.LocalizationKey
  public static let firstName: Elements.LocalizationKey
  public static let cardPinTitle: Elements.LocalizationKey
  public static let missingField: Elements.LocalizationKey
  public static let cardApplyGiftcard: Elements.LocalizationKey
  public static let voucherCollectionInstitutionNumber: Elements.LocalizationKey
  public static let voucherMerchantName: Elements.LocalizationKey
  public static let voucherExpirationDate: Elements.LocalizationKey
  public static let voucherPaymentReferenceLabel: Elements.LocalizationKey
  public static let voucherShopperName: Elements.LocalizationKey
  public static let buttonCopy: Elements.LocalizationKey
  public static let voucherIntroduction: Elements.LocalizationKey
  public static let voucherReadInstructions: Elements.LocalizationKey
  public static let voucherSaveImage: Elements.LocalizationKey
  public static let voucherFinish: Elements.LocalizationKey
  public static let pixInstructions: Elements.LocalizationKey
  public static let pixCopyButton: Elements.LocalizationKey
  public static let pixExpirationLabel: Elements.LocalizationKey
  public static let billingAddressSectionTitle: Elements.LocalizationKey
  public static let deliveryAddressSectionTitle: Elements.LocalizationKey
  public static let countryFieldTitle: Elements.LocalizationKey
  public static let addressFieldTitle: Elements.LocalizationKey
  public static let addressFieldPlaceholder: Elements.LocalizationKey
  public static let streetFieldTitle: Elements.LocalizationKey
  public static let streetFieldPlaceholder: Elements.LocalizationKey
  public static let houseNumberFieldTitle: Elements.LocalizationKey
  public static let houseNumberFieldPlaceholder: Elements.LocalizationKey
  public static let cityFieldTitle: Elements.LocalizationKey
  public static let cityFieldPlaceholder: Elements.LocalizationKey
  public static let cityTownFieldTitle: Elements.LocalizationKey
  public static let cityTownFieldPlaceholder: Elements.LocalizationKey
  public static let postalCodeFieldTitle: Elements.LocalizationKey
  public static let postalCodeFieldPlaceholder: Elements.LocalizationKey
  public static let zipCodeFieldTitle: Elements.LocalizationKey
  public static let zipCodeFieldPlaceholder: Elements.LocalizationKey
  public static let stateFieldTitle: Elements.LocalizationKey
  public static let stateFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateFieldPlaceholder: Elements.LocalizationKey
  public static let stateOrProvinceFieldTitle: Elements.LocalizationKey
  public static let stateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldTitle: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldPlaceholder: Elements.LocalizationKey
  public static let apartmentSuiteFieldTitle: Elements.LocalizationKey
  public static let apartmentSuiteFieldPlaceholder: Elements.LocalizationKey
  public static let errorFeedbackEmptyField: Elements.LocalizationKey
  public static let errorFeedbackIncorrectFormat: Elements.LocalizationKey
  public static let fieldTitleOptional: Elements.LocalizationKey
  public static let threedsNotAuthenticatedError: Elements.LocalizationKey
  public static let threedsAuthenticationTimeout: Elements.LocalizationKey
  public static let errorSomethingWentWrong: Elements.LocalizationKey
  public init(key: Swift.String)
}
final public class CardNumberValidator : Elements.Validator {
  public init()
  final public func isValid(_ value: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
@objc open class FormViewController : UIKit.UIViewController, Elements.Localizable, Elements.KeyboardObserver, Elements.Observer, Elements.PreferredContentSizeConsumer {
  public var requiresKeyboardInput: Swift.Bool {
    get
  }
  final public let style: Elements.ViewStyle
  weak public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ViewStyle)
  @objc deinit
  @available(*, unavailable)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  public var keyboardObserver: Any?
  public func startObserving()
  public func willUpdatePreferredContentSize()
  public func didUpdatePreferredContentSize()
  public func append<T>(_ item: T) where T : Elements.FormItem
  public var localizationParameters: Elements.LocalizationParameters?
  public func validate() -> Swift.Bool
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @discardableResult
  @objc override dynamic public func resignFirstResponder() -> Swift.Bool
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension FormViewController : Elements.FormTextItemViewDelegate {
  public func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  public func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
extension FormViewController {
  @objc dynamic public func authenticationPresentingViewController() -> UIKit.UIViewController
  @objc dynamic public func configureSafariViewController(_ viewController: SafariServices.SFSafariViewController)
  @objc dynamic public func authenticationContextWillDismiss(_ viewController: UIKit.UIViewController)
}
public struct ApplePayTokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.ElementsToken
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
}
final public class FullScreenWallet {
  public init(configuration: Elements.Blocks.Configuration)
  final public func createFlowViewController() -> UIKit.UIViewController?
  @objc deinit
}
public struct RedirectAction : Swift.Decodable {
  public let url: Foundation.URL
  public let paymentData: Swift.String?
  public init(url: Foundation.URL, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
@propertyWrapper final public class Observable<ValueType> : Elements.EventPublisher where ValueType : Swift.Equatable {
  public init(_ value: ValueType)
  final public var wrappedValue: ValueType {
    get
    set
  }
  public typealias Event = ValueType
  final public var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Elements.Observable<ValueType>.Event>]
  final public var projectedValue: Elements.Observable<ValueType> {
    get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSLabelCustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSLabelCustomization
  @objc public var headingFont: UIKit.UIFont {
    @objc get
    @objc set(headingFont)
  }
  @objc public var headingTextColor: UIKit.UIColor {
    @objc get
    @objc set(headingTextColor)
  }
  @objc public var font: UIKit.UIFont? {
    @objc get
    @objc set(font)
  }
  @objc public var textColor: UIKit.UIColor? {
    @objc get
    @objc set(textColor)
  }
  @objc deinit
  @objc override dynamic public init()
}
public struct ListStoredPaymentMethodsResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
public typealias URLHandler = (Foundation.URL) -> Swift.Void
public enum RedirectListener {
  public static func registerForURL(using handler: @escaping Elements.URLHandler)
}
extension DropInElement {
  final public class PaymentMethodsConfiguration {
    final public var card: Elements.DropInElement.CardConfiguration
    final public var applePay: Elements.DropInElement.ApplePayConfiguration?
    final public let environment: Elements.Environment
    final public var localizationParameters: Elements.LocalizationParameters?
    final public var payment: Elements.Payment?
    public init(environment: Elements.Environment)
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class CardConfiguration {
    final public var showsHolderNameField: Swift.Bool
    final public var showsStorePaymentMethodField: Swift.Bool
    final public var showsSecurityCodeField: Swift.Bool
    final public var billingAddress: Elements.CardElement.AddressFormType
    final public var stored: Elements.StoredCardConfiguration
    @objc deinit
  }
  final public class ApplePayConfiguration {
    final public var summaryItems: [PassKit.PKPaymentSummaryItem]
    final public var merchantIdentifier: Swift.String
    final public var merchantName: Swift.String
    final public var requiredBillingContactFields: Swift.Set<PassKit.PKContactField>
    final public var requiredShippingContactFields: Swift.Set<PassKit.PKContactField>
    final public var excludedCardNetworks: [PassKit.PKPaymentNetwork]
    public init(summaryItems: [PassKit.PKPaymentSummaryItem], merchantIdentifier: Swift.String, requiredBillingContactFields: Swift.Set<PassKit.PKContactField> = [], requiredShippingContactFields: Swift.Set<PassKit.PKContactField> = [])
    @objc deinit
  }
}
public struct PhoneExtension : Swift.Decodable, Swift.Equatable {
  public let value: Swift.String
  public let countryCode: Swift.String
  public var countryDisplayName: Swift.String {
    get
  }
  public init(value: Swift.String, countryCode: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.PhoneExtension, b: Elements.PhoneExtension) -> Swift.Bool
}
public enum PhoneNumberPaymentMethod {
  case qiwiWallet
  case mbWay
  case generic
  public static func == (a: Elements.PhoneNumberPaymentMethod, b: Elements.PhoneNumberPaymentMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct PhoneExtensionsQuery {
  public let codes: [Swift.String]
  public init(codes: [Swift.String])
  public init(paymentMethod: Elements.PhoneNumberPaymentMethod)
}
public enum PhoneExtensionsRepository {
  public static func get(with query: Elements.PhoneExtensionsQuery) -> [Elements.PhoneExtension]
}
public struct ElementsScope<Base> {
  public let base: Base
  public init(base: Base)
}
public protocol ElementsCompatible {
  associatedtype ElementsBase
  var elements: Elements.ElementsScope<Self.ElementsBase> { get }
}
extension ElementsCompatible {
  public var elements: Elements.ElementsScope<Self> {
    get
  }
}
public struct ListItemStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var subtitle: Elements.TextStyle
  public var image: Elements.ImageStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle, subtitle: Elements.TextStyle, image: Elements.ImageStyle)
  public init()
}
extension ListItemStyle : Swift.Equatable {
  public static func == (lhs: Elements.ListItemStyle, rhs: Elements.ListItemStyle) -> Swift.Bool
}
public protocol DropInElementDelegate : AnyObject {
  func didSubmit(_ data: Elements.PaymentElementData, for paymentMethod: Elements.PaymentMethod, from element: Elements.DropInElement)
  func didProvide(_ data: Elements.ActionElementData, from element: Elements.DropInElement)
  func didComplete(from element: Elements.DropInElement, token: Swift.String)
  func didFail(with error: Swift.Error, from element: Elements.DropInElement)
  func didCancel(element: Elements.PaymentElement, from dropInElement: Elements.DropInElement)
}
extension DropInElementDelegate {
  public func didCancel(element: Elements.PaymentElement, from dropInElement: Elements.DropInElement)
}
public protocol APIEnvironment {
  var baseURL: Foundation.URL { get }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
}
public struct ElementsCardResponse : Swift.Codable {
  public let id: Swift.String
  public let last4: Swift.String?
  public let expiryMonth: Swift.UInt?
  public let expiryYear: Swift.UInt?
  public let brand: Swift.String?
  public let fingerprint: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ElementsToken : Elements.Response {
  public let id: Swift.String
  public let card: Elements.ElementsCardResponse?
  public init(id: Swift.String, card: Elements.ElementsCardResponse?)
  public init(from decoder: Swift.Decoder) throws
}
public protocol Validator {
  func isValid(_ value: Swift.String) -> Swift.Bool
  func maximumLength(for value: Swift.String) -> Swift.Int
}
public protocol CardElementDelegate : AnyObject {
  func didChangeBIN(_ value: Swift.String, element: Elements.CardElement)
  func didChangeCardBrand(_ value: [Elements.CardBrand]?, element: Elements.CardElement)
}
public class CardElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable, Elements.Observer, Elements.LoadingElement {
  final public let style: Elements.FormElementStyle
  public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak public var cardElementDelegate: Elements.CardElementDelegate?
  final public let supportedCardTypes: [Elements.CardType]
  final public let configuration: Elements.CardElement.Configuration
  weak public var delegate: Elements.PaymentElementDelegate? {
    get
    set
  }
  public var payment: Elements.Payment? {
    get
    set
  }
  public var environment: Elements.Environment {
    get
    set
  }
  public init(paymentMethod: Elements.AnyCardPaymentMethod, configuration: Elements.CardElement.Configuration = Configuration(), style: Elements.FormElementStyle = FormElementStyle())
  public var viewController: UIKit.UIViewController {
    get
  }
  public var requiresModalPresentation: Swift.Bool {
    get
  }
  public var localizationParameters: Elements.LocalizationParameters?
  public func stopLoading()
  @objc deinit
}
public struct CardDetails : Elements.PaymentMethodDetails, Elements.BillingAddressInformation {
  public let type: Swift.String
  public let storedPaymentMethodIdentifier: Swift.String?
  public let card: Elements.ElementsCardParams?
  public let fundingSource: Elements.CardFundingSource?
  public var billingAddress: Elements.AddressInfo?
  public init(paymentMethod: Elements.AnyCardPaymentMethod, card: Elements.ElementsCardParams, holderName: Swift.String? = nil, billingAddress: Elements.AddressInfo? = nil)
  public init(paymentMethod: Elements.StoredPaymentMethod, securityCode: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PaymentMethods : Swift.Decodable {
  public let regular: [Elements.PaymentMethod]
  public let stored: [Elements.StoredPaymentMethod]
  public init(regular: [Elements.PaymentMethod], stored: [Elements.StoredPaymentMethod])
  public func paymentMethod<T>(ofType type: T.Type) -> T? where T : Elements.PaymentMethod
  public init(from decoder: Swift.Decoder) throws
}
public enum AnyPaymentMethod : Swift.Decodable {
  case card(Elements.AnyCardPaymentMethod)
  case issuerList(Elements.IssuerListPaymentMethod)
  case redirect(Elements.RedirectPaymentMethod)
  case applePay(Elements.ApplePayPaymentMethod)
  case wallets(Elements.WalletsPaymentMethod)
  case none
  public var value: Elements.PaymentMethod? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
final public class FormSeparatorItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let color: UIKit.UIColor
  final public var identifier: Swift.String?
  public init(color: UIKit.UIColor)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AppNavigationController : Elements.NavigationController {
  @objc override dynamic public func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool)
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc deinit
}
public protocol ActionElement : Elements.Element {
  var delegate: Elements.ActionElementDelegate? { get set }
}
public protocol ActionElementDelegate : AnyObject {
  func didOpenExternalApplication(_ element: Elements.ActionElement)
  func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  func didComplete(from element: Elements.ActionElement)
  func didFail(with error: Swift.Error, from element: Elements.ActionElement)
}
extension ActionElementDelegate {
  public func didOpenExternalApplication(_: Elements.ActionElement)
}
public protocol PresentationDelegate : AnyObject {
  func present(element: Elements.PresentableElement)
}
@_inheritsConvenienceInitializers final public class CardSecurityCodeFormatter : Elements.NumericFormatter, Elements.Observer {
  override public init()
  public init(publisher: Elements.Observable<Elements.CardType?>)
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol APIClientProtocol {
  typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  func perform<R>(_ request: R, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class APIClient : Elements.APIClientProtocol {
  final public let environment: Elements.APIEnvironment
  public init(environment: Elements.APIEnvironment)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.APIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@_inheritsConvenienceInitializers open class NumericStringValidator : Elements.LengthValidator {
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  @objc deinit
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
}
extension UIActivityIndicatorView.Style {
}
@_inheritsConvenienceInitializers final public class FormTextInputItem : Elements.FormTextItem {
  override public init(style: Elements.FormTextItemStyle = .init())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol AnyCardPaymentMethod : Elements.PaymentMethod {
  var cardData: [Elements.SupportedCardData] { get }
  var fundingSource: Elements.CardFundingSource? { get }
}
public enum CardFundingSource : Swift.String, Swift.Codable {
  case debit
  case credit
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol AnyAppLauncher {
  func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
public struct AppLauncher : Elements.AnyAppLauncher {
  public init()
  public func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  public func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class FullScreenWalletViewController : Elements.BaseListViewController {
  @objc override final public func viewDidLoad()
  @objc deinit
}
public typealias Completion<T> = (T) -> Swift.Void
extension UIButton {
  convenience public init(style: Elements.ButtonStyle)
}
extension CardElement {
  public enum Error : Swift.Error {
    case missingClientKey
    public static func == (a: Elements.CardElement.Error, b: Elements.CardElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension CardElement : Elements.TrackableElement {
  public func viewDidLoad(viewController: UIKit.UIViewController)
}
public func localizedString(_ key: Elements.LocalizationKey, _ parameters: Elements.LocalizationParameters?, _ arguments: Swift.CVarArg...) -> Swift.String
public enum PaymentStyle {
  case needsRedirectToThirdParty(Swift.String)
  case immediate
}
public func localizedSubmitButtonTitle(with amount: Elements.Payment.Amount?, style: Elements.PaymentStyle, _ parameters: Elements.LocalizationParameters?) -> Swift.String
@objc final public class ListViewController : UIKit.UITableViewController {
  final public let style: Elements.ListElementStyle
  weak final public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ListElementStyle = ListElementStyle())
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  final public var sections: [Elements.ListItemsSection] {
    get
    set
  }
  final public func startLoading(for item: Elements.ListItem)
  final public func stopLoading()
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @objc override final public func numberOfSections(in _: UIKit.UITableView) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override final public func tableView(_: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc override final public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override final public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public enum ShopperInteraction : Swift.String, Swift.Decodable {
  case shopperPresent
  case shopperNotPresent
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers open class ListValueSectionController<Value> : ElementsListKit.ListSectionController where Value : Elements.ListIdentifiable {
  public var value: Value! {
    get
  }
  @objc final override public func didUpdate(to object: Any)
  open func didUpdate(to value: Value)
  @objc deinit
  @objc override dynamic public init()
}
public struct FormButtonItemStyle : Elements.ViewStyle {
  public var button: Elements.ButtonStyle
  public var backgroundColor: UIKit.UIColor
  public init(button: Elements.ButtonStyle)
  public init(button: Elements.ButtonStyle, background: UIKit.UIColor)
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRounding: Elements.CornerRounding) -> Elements.FormButtonItemStyle
  public static func secondary(font: UIKit.UIFont, textColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
}
public class FormLabelItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(text: Swift.String, style: Elements.TextStyle, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var style: Elements.TextStyle
  public var text: Swift.String
  public func build(with _: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc public enum STPThreeDSCustomizationButtonType : Swift.Int {
  case submit = 0
  case `continue` = 1
  case next = 2
  case cancel = 3
  case resend = 4
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum STPThreeDSButtonTitleStyle : Swift.Int {
  case `default`
  case uppercase
  case lowercase
  case sentenceCapitalized
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class STPThreeDSButtonCustomization : ObjectiveC.NSObject {
  @objc(defaultSettingsForButtonType:) public class func defaultSettings(for type: Elements.STPThreeDSCustomizationButtonType) -> Elements.STPThreeDSButtonCustomization
  @objc public init(backgroundColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat)
  @objc public var backgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc public var titleStyle: Elements.STPThreeDSButtonTitleStyle {
    @objc get
    @objc set
  }
  @objc public var font: UIKit.UIFont? {
    @objc get
    @objc set(font)
  }
  @objc public var textColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init()
}
public class FormContainerItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(content: Elements.FormItem, padding: UIKit.UIEdgeInsets = .zero, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var content: Elements.FormItem {
    get
  }
  public var padding: UIKit.UIEdgeInsets
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension FormItem {
  public func withPadding(padding: UIKit.UIEdgeInsets) -> Elements.FormContainerItem
}
public struct ImageStyle : Elements.TintableStyle {
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var cornerRounding: Elements.CornerRounding
  public var clipsToBounds: Swift.Bool
  public var contentMode: UIKit.UIView.ContentMode
  public var backgroundColor: UIKit.UIColor
  public var tintColor: UIKit.UIColor?
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRadius: CoreGraphics.CGFloat, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRounding: Elements.CornerRounding, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
}
extension ImageStyle : Swift.Equatable {
  public static func == (lhs: Elements.ImageStyle, rhs: Elements.ImageStyle) -> Swift.Bool
}
public protocol Observer : AnyObject {
}
extension Observer {
  @discardableResult
  public func observe<T>(_ eventPublisher: T, eventHandler: @escaping Elements.EventHandler<T.Event>) -> Elements.Observation where T : Elements.EventPublisher
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>, with transformation: @escaping ((Value) -> Result)) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  public func remove(_ observation: Elements.Observation)
}
public struct PhoneExtensionViewModel : Swift.CustomStringConvertible, Swift.Equatable {
  public let title: Swift.String
  public let phoneExtension: Swift.String
  public var description: Swift.String {
    get
  }
  public static func == (a: Elements.PhoneExtensionViewModel, b: Elements.PhoneExtensionViewModel) -> Swift.Bool
}
public typealias PhoneExtensionPickerItem = Elements.BasePickerElement<Elements.PhoneExtensionViewModel>
@_hasMissingDesignatedInitializers final public class FormPhoneExtensionPickerItem : Elements.BaseFormPickerItem<Elements.PhoneExtensionViewModel> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public typealias RegionPickerItem = Elements.BasePickerElement<Elements.Region>
@_hasMissingDesignatedInitializers final public class FormRegionPickerItem : Elements.BaseFormPickerItem<Elements.Region> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol Dependency : AnyObject {
}
public protocol EmptyDependency : Elements.Dependency {
}
public struct RedirectDetails : Elements.AdditionalDetails {
  public let returnURL: Foundation.URL
  public init(returnURL: Foundation.URL)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListElementStyle : Elements.ViewStyle {
  public var listItem: Elements.ListItemStyle
  public var sectionHeader: Elements.ListSectionHeaderStyle
  public var backgroundColor: UIKit.UIColor
  public init(listItem: Elements.ListItemStyle, sectionHeader: Elements.ListSectionHeaderStyle)
  public init()
}
extension Bundle : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.Bundle
}
extension ElementsScope where Base : Foundation.Bundle {
  public func isSchemeConfigured(_ scheme: Swift.String) -> Swift.Bool
}
public struct Region : Swift.Decodable, Swift.CustomStringConvertible, Swift.Equatable {
  public let identifier: Swift.String
  public let name: Swift.String
  public var description: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.Region, b: Elements.Region) -> Swift.Bool
}
public class RegionRepository {
  public init(environment: Elements.Environment)
  public func getCountries(locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  public func getSubRegions(for countryCode: Swift.String, locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  @objc deinit
}
public enum PKPaymentMethodTypeWrapper : Swift.String, Swift.Codable {
  case unknown
  case debit
  case credit
  case prepaid
  case store
  public init?(type: PassKit.PKPaymentMethodType?)
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct PKPaymentMethodDetails : Elements.PaymentMethodDetails {
  public let displayName: Swift.String?
  public let network: Swift.String?
  public let type: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ApplePayDetails : Elements.PaymentMethodDetails {
  public let token: Swift.String
  public let paymentMethodDetails: Elements.PKPaymentMethodDetails
  public let billingContact: PassKit.PKContact?
  public let shippingContact: PassKit.PKContact?
  public let transactionIdentifier: Swift.String?
  public init(token: Swift.String, paymentMethodDetails: Elements.PKPaymentMethodDetails, billingContact: PassKit.PKContact?, shippingContact: PassKit.PKContact?, transactionIdentifier: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
}
public enum ImageResources : Swift.String, Swift.CaseIterable {
  case icon_checkmark
  case icon_chevron_left
  case icon_chevron_down
  case icon_lock
  case icon_plus
  case icon_x
  case ic_card_front
  case ic_right_triangle_icon
  public func getImage() -> UIKit.UIImage
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [Elements.ImageResources]
  public static var allCases: [Elements.ImageResources] {
    get
  }
}
public protocol ImageAssets {
  var icon_checkmark: UIKit.UIImage { get }
  var icon_chevron_left: UIKit.UIImage { get }
  var icon_chevron_down: UIKit.UIImage { get }
  var icon_lock: UIKit.UIImage { get }
  var icon_plus: UIKit.UIImage { get }
  var icon_x: UIKit.UIImage { get }
  var ic_card_front: UIKit.UIImage { get }
  var ic_right_triangle_icon: UIKit.UIImage { get }
}
final public class LightThemeAssets : Elements.ImageAssets {
  final public var ic_right_triangle_icon: UIKit.UIImage {
    get
  }
  final public var icon_checkmark: UIKit.UIImage {
    get
  }
  final public var icon_chevron_left: UIKit.UIImage {
    get
  }
  final public var icon_chevron_down: UIKit.UIImage {
    get
  }
  final public var icon_lock: UIKit.UIImage {
    get
  }
  final public var icon_plus: UIKit.UIImage {
    get
  }
  final public var icon_x: UIKit.UIImage {
    get
  }
  final public var ic_card_front: UIKit.UIImage {
    get
  }
  public init()
  @objc deinit
}
final public class DarkThemeAssets : Elements.ImageAssets {
  final public var ic_right_triangle_icon: UIKit.UIImage {
    get
  }
  final public var icon_checkmark: UIKit.UIImage {
    get
  }
  final public var icon_chevron_left: UIKit.UIImage {
    get
  }
  final public var icon_chevron_down: UIKit.UIImage {
    get
  }
  final public var icon_lock: UIKit.UIImage {
    get
  }
  final public var icon_plus: UIKit.UIImage {
    get
  }
  final public var icon_x: UIKit.UIImage {
    get
  }
  final public var ic_card_front: UIKit.UIImage {
    get
  }
  public init()
  @objc deinit
}
final public class LogoURLProvider {
  public init(environment: Elements.Environment)
  final public func logoURL(for paymentMethod: Elements.PaymentMethod, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL?
  final public func logoURL(withName name: Swift.String, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  public static func logoURL(withName name: Swift.String, environment: Elements.Environment, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  @objc deinit
}
extension LogoURLProvider {
  public enum Size : Swift.String {
    case small
    case medium
    case large
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
infix operator |> : AdditionPrecedence
public enum HTTPMethod : Swift.String {
  case post
  case get
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public protocol Request : Swift.Encodable {
  associatedtype ResponseType : Elements.Response
  var path: Swift.String { get }
  var counter: Swift.UInt { get set }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
  var method: Elements.HTTPMethod { get }
}
public protocol Response : Swift.Decodable {
}
public protocol PaymentElementBuilder {
  func build(paymentMethod: Elements.StoredPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.CardPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.ApplePayPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.WalletsPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.PaymentMethod) -> Elements.PaymentElement?
}
final public class StoredPaymentMethodElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable {
  final public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak final public var delegate: Elements.PaymentElementDelegate?
  public init(paymentMethod: Elements.StoredPaymentMethod)
  final public var viewController: UIKit.UIViewController {
    get
    set
  }
  final public var localizationParameters: Elements.LocalizationParameters?
  @objc deinit
}
public struct StoredPaymentDetails : Elements.PaymentMethodDetails {
  public init(paymentMethod: Elements.StoredPaymentMethod)
  public func encode(to encoder: Swift.Encoder) throws
}
open class ComponentizedBuilder<Component, Router, DynamicBuildDependency, DynamicComponentDependency> : Elements.Buildable {
  public init(componentBuilder: @escaping (DynamicComponentDependency) -> Component)
  final public func build(withDynamicBuildDependency dynamicBuildDependency: DynamicBuildDependency, dynamicComponentDependency: DynamicComponentDependency) -> Router
  final public func build(withDynamicBuildDependency dynamicBuildDependency: DynamicBuildDependency, dynamicComponentDependency: DynamicComponentDependency) -> (Component, Router)
  open func build(with component: Component, _ dynamicBuildDependency: DynamicBuildDependency) -> Router
  @objc deinit
}
open class SimpleComponentizedBuilder<Component, Router> : Elements.ComponentizedBuilder<Component, Router, (), ()> {
  public init(componentBuilder: @escaping () -> Component)
  final override public func build(with component: Component, _ dynamicDependency: ()) -> Router
  open func build(with component: Component) -> Router
  final public func build() -> Router
  @objc deinit
  override public init(componentBuilder: @escaping (()) -> Component)
}
final public class CardSecurityCodeValidator : Elements.NumericStringValidator, Elements.Observer {
  public init()
  public init(publisher: Elements.Observable<Elements.CardType?>)
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
public struct LocalizationParameters : Swift.Equatable {
  public let locale: Swift.String?
  public let tableName: Swift.String?
  public let keySeparator: Swift.String?
  public let bundle: Foundation.Bundle?
  public init(bundle: Foundation.Bundle? = nil, tableName: Swift.String? = nil, keySeparator: Swift.String? = nil, locale: Swift.String? = nil)
  public static func == (a: Elements.LocalizationParameters, b: Elements.LocalizationParameters) -> Swift.Bool
}
public struct ApplePayPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let brands: [Swift.String]?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, brands: [Swift.String]?)
  public init(from decoder: Swift.Decoder) throws
}
public struct AddressInfo : Swift.Equatable, Swift.Encodable {
  public init(city: Swift.String? = nil, country: Swift.String? = nil, houseNumberOrName: Swift.String? = nil, postalCode: Swift.String? = nil, stateOrProvince: Swift.String? = nil, street: Swift.String? = nil, apartment: Swift.String? = nil)
  public var city: Swift.String?
  public var country: Swift.String?
  public var houseNumberOrName: Swift.String?
  public var postalCode: Swift.String?
  public var stateOrProvince: Swift.String?
  public var street: Swift.String?
  public var apartment: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: Elements.AddressInfo, b: Elements.AddressInfo) -> Swift.Bool
}
public struct ListSectionHeaderStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
@_inheritsConvenienceInitializers final public class FormSwitchItemView : Elements.FormValueItemView<Swift.Bool, Elements.FormSwitchItemStyle, Elements.FormSwitchItem> {
  required public init(item: Elements.FormSwitchItem)
  @objc override final public func accessibilityActivate() -> Swift.Bool
  @objc deinit
}
public protocol KeyboardObserver : AnyObject {
  func startObserving()
  func stopObserving()
  var keyboardObserver: Any? { get set }
}
extension KeyboardObserver {
  public func startObserving(_ observer: @escaping (CoreGraphics.CGRect) -> Swift.Void)
  public func stopObserving()
}
final public class PhoneNumberValidator : Elements.RegularExpressionValidator {
  public init()
  override public init(regularExpression: Swift.String, minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
public struct ButtonStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat, background: UIKit.UIColor)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding, background: UIKit.UIColor)
}
public class ElementsCardParams : Swift.Codable {
  final public let cardNumber: Swift.String
  final public let expiryMonth: Swift.UInt?
  final public let expiryYear: Swift.UInt?
  final public let securityCode: Swift.String?
  final public let holderName: Swift.String?
  final public let addressLine1: Swift.String?
  final public let addressLine2: Swift.String?
  final public let city: Swift.String?
  final public let state: Swift.String?
  final public let postalCode: Swift.String?
  final public let country: Swift.String?
  public init(cardNumber: Swift.String, expiryMonth: Swift.UInt?, expiryYear: Swift.UInt?, securityCode: Swift.String?, holderName: Swift.String?, addressLine1: Swift.String? = nil, addressLine2: Swift.String? = nil, city: Swift.String? = nil, state: Swift.String? = nil, postalCode: Swift.String? = nil, country: Swift.String? = nil)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias AssertionListner = (Swift.String) -> Swift.Void
public enum ElementsAssertion {
  public static func assert(message: Swift.String)
}
public struct Observation : Swift.Hashable {
  public static func == (lhs: Elements.Observation, rhs: Elements.Observation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class DropInElement : ObjectiveC.NSObject, Elements.PresentableElement {
  final public let paymentMethods: Elements.PaymentMethods
  weak final public var delegate: Elements.DropInElementDelegate?
  final public let style: Elements.DropInElement.Style
  final public let title: Swift.String
  public init(paymentMethods: Elements.PaymentMethods, paymentMethodsConfiguration: Elements.Blocks.Configuration, style: Elements.DropInElement.Style = Style(), title: Swift.String? = nil)
  final public var viewController: UIKit.UIViewController {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension DropInElement : Elements.ElementsActionCompletionDelegate {
  final public func didFail(with error: Swift.Error, driver: Elements.ElementsActionDriver)
  final public func didSuccess(with token: Swift.String?, driver: Elements.ElementsActionDriver)
}
extension DropInElement : Elements.ElementsViewControllerPresentingDelegate {
  final public func requestToShow(viewController: UIKit.UIViewController)
  final public func requestToDismiss()
}
extension DropInElement : Elements.PaymentElementDelegate {
  final public func didSubmit(_ data: Elements.PaymentElementData, from element: Elements.PaymentElement)
  final public func didFail(with error: Swift.Error, from element: Elements.PaymentElement)
}
extension DropInElement : Elements.PresentationDelegate {
  final public func present(element: Elements.PresentableElement)
}
extension DropInElement : Elements.FinalizableElement {
  final public func didFinalize(with success: Swift.Bool)
}
public protocol Formatter {
  func formattedValue(for value: Swift.String) -> Swift.String
  func sanitizedValue(for value: Swift.String) -> Swift.String
}
public struct TextStyle : Elements.ViewStyle {
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var textAlignment: UIKit.NSTextAlignment
  public var backgroundColor: UIKit.UIColor
  public var cornerRounding: Elements.CornerRounding
  public init(font: UIKit.UIFont, color: UIKit.UIColor, textAlignment: UIKit.NSTextAlignment)
  public init(font: UIKit.UIFont, color: UIKit.UIColor)
}
extension TextStyle : Swift.Equatable {
  public static func == (lhs: Elements.TextStyle, rhs: Elements.TextStyle) -> Swift.Bool
}
public protocol ColorSchema {
  var themeColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
  var lightBackgroundColor: UIKit.UIColor { get }
  var shadowColor: UIKit.UIColor { get }
  var primaryTextColorDarkCanvas: UIKit.UIColor { get }
  var secondaryTextColorDarkCanvas: UIKit.UIColor { get }
  var primaryTextColorLightCanvas: UIKit.UIColor { get }
  var secondaryTextColorLightCanvas: UIKit.UIColor { get }
  var errorColor: UIKit.UIColor { get }
  var separatorColor: UIKit.UIColor { get }
}
final public class LightThemeColors : Elements.ColorSchema {
  public init()
  final public var themeColor: UIKit.UIColor {
    get
  }
  final public var backgroundColor: UIKit.UIColor {
    get
  }
  final public var lightBackgroundColor: UIKit.UIColor {
    get
  }
  final public var shadowColor: UIKit.UIColor {
    get
  }
  final public var primaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var primaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var separatorColor: UIKit.UIColor {
    get
  }
  final public var errorColor: UIKit.UIColor {
    get
  }
  @objc deinit
}
public enum Action : Swift.Decodable {
  case redirect(Elements.RedirectAction)
  public init(from decoder: Swift.Decoder) throws
}
public struct FormItemViewBuilder {
  public func build(with item: Elements.FormSwitchItem) -> Elements.FormItemView<Elements.FormSwitchItem>
  public func build(with item: Elements.FormSplitItem) -> Elements.FormItemView<Elements.FormSplitItem>
  public func build(with item: Elements.FormPhoneNumberItem) -> Elements.FormItemView<Elements.FormPhoneNumberItem>
  public func build(with item: Elements.FormPhoneExtensionPickerItem) -> Elements.BaseFormPickerItemView<Elements.PhoneExtensionViewModel>
  public func build(with item: Elements.FormRegionPickerItem) -> Elements.BaseFormPickerItemView<Elements.Region>
  public func build(with item: Elements.FormTextInputItem) -> Elements.FormItemView<Elements.FormTextInputItem>
  public func build(with item: Elements.ListItem) -> Elements.ListItemView
  public func build(with item: Elements.FormButtonItem) -> Elements.FormItemView<Elements.FormButtonItem>
  public func build(with item: Elements.FormSeparatorItem) -> Elements.FormItemView<Elements.FormSeparatorItem>
  public func build(with item: Elements.FormErrorItem) -> Elements.FormItemView<Elements.FormErrorItem>
  public func build(with item: Elements.FullFormAddressItem) -> Elements.FormItemView<Elements.FullFormAddressItem>
  public static func build(_ item: Elements.FormItem) -> Elements.AnyFormItemView
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc deinit
  @objc override dynamic public init()
}
extension SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct ContactDetail : Swift.Codable {
  public let emailAdress: Swift.String?
  public let phoneNumber: Swift.String?
  public let postalAddress: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol PaymentMethodAware {
  var paymentMethod: Elements.PaymentMethod { get }
}
public protocol PaymentElement : Elements.PaymentAwareElement, Elements.PaymentMethodAware {
  var delegate: Elements.PaymentElementDelegate? { get set }
}
extension PaymentElement {
  public func submit(data: Elements.PaymentElementData, element: Elements.PaymentElement? = nil)
}
public protocol PaymentElementDelegate : AnyObject {
  func didSubmit(_ data: Elements.PaymentElementData, from element: Elements.PaymentElement)
  func didFail(with error: Swift.Error, from element: Elements.PaymentElement)
}
public protocol PaymentAwareElement : Elements.Element {
  var payment: Elements.Payment? { get set }
}
extension PaymentAwareElement {
  public var payment: Elements.Payment? {
    get
    set
  }
}
extension URLSession : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.URLSession
}
extension ElementsScope where Base : Foundation.URLSession {
  public func dataTask(with url: Foundation.URL, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
  public func dataTask(with urlRequest: Foundation.URLRequest, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
}
public struct ChargeAPIResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
extension ElementsScope where Base : UIKit.UIViewController {
  public var topPresenter: UIKit.UIViewController {
    get
  }
  public func present(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
}
extension UIResponder : Elements.ElementsCompatible {
  public typealias ElementsBase = UIKit.UIResponder
}
public protocol PreferredContentSizeConsumer {
  func didUpdatePreferredContentSize()
  func willUpdatePreferredContentSize()
}
public struct FormTextItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var text: Elements.TextStyle
  public var placeholderText: Elements.TextStyle?
  public var icon: Elements.ImageStyle
  public var tintColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public init(title: Elements.TextStyle, text: Elements.TextStyle, placeholderText: Elements.TextStyle? = nil, icon: Elements.ImageStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSUICustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSUICustomization
  @objc public var navigationBarCustomization: Elements.STPThreeDSNavigationBarCustomization {
    @objc get
    @objc set(navigationBarCustomization)
  }
  @objc public var labelCustomization: Elements.STPThreeDSLabelCustomization {
    @objc get
    @objc set(labelCustomization)
  }
  @objc public var textFieldCustomization: Elements.STPThreeDSTextFieldCustomization {
    @objc get
    @objc set(textFieldCustomization)
  }
  @objc public var backgroundColor: UIKit.UIColor {
    @objc get
    @objc set(backgroundColor)
  }
  @objc public var footerCustomization: Elements.STPThreeDSFooterCustomization {
    @objc get
    @objc set(footerCustomization)
  }
  @objc(setButtonCustomization:forType:) public func setButtonCustomization(_ buttonCustomization: Elements.STPThreeDSButtonCustomization, for buttonType: Elements.STPThreeDSCustomizationButtonType)
  @objc(buttonCustomizationForButtonType:) public func buttonCustomization(for buttonType: Elements.STPThreeDSCustomizationButtonType) -> Elements.STPThreeDSButtonCustomization
  @objc public var selectionCustomization: Elements.STPThreeDSSelectionCustomization {
    @objc get
    @objc set(selectionCustomization)
  }
  @objc public var activityIndicatorViewStyle: UIKit.UIActivityIndicatorView.Style {
    @objc get
    @objc set(activityIndicatorViewStyle)
  }
  @objc public var blurStyle: UIKit.UIBlurEffect.Style {
    @objc get
    @objc set(blurStyle)
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class PresentableElementWrapper : Elements.PresentableElement, Elements.Cancellable, Elements.FinalizableElement, Elements.LoadingElement {
  final public let viewController: UIKit.UIViewController
  final public let element: Elements.Element
  final public var requiresModalPresentation: Swift.Bool
  public init(element: Elements.Element, viewController: UIKit.UIViewController)
  final public func didCancel()
  final public func didFinalize(with success: Swift.Bool)
  final public func stopLoading()
  @objc deinit
}
public struct TokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.TokenizationResponse
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSCustomizationSettings : ObjectiveC.NSObject {
  @available(*, deprecated, message: "Use STPThreeDSCustomizationSettings() instead of STPThreeDSCustomizationSettings.defaultSettings().")
  @objc public class func defaultSettings() -> Elements.STPThreeDSCustomizationSettings
  @objc public var uiCustomization: Elements.STPThreeDSUICustomization
  @objc public var authenticationTimeout: Swift.Int
  @objc deinit
  @objc override dynamic public init()
}
public enum ViewIdentifierBuilder {
  public static func build(scopeInstance: Any, postfix: Swift.String) -> Swift.String
}
public struct AnyEncodable : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
open class NumericFormatter : Elements.Formatter {
  public init()
  open func formattedValue(for value: Swift.String) -> Swift.String
  open func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSNavigationBarCustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSNavigationBarCustomization
  @objc public var barTintColor: UIKit.UIColor? {
    @objc get
    @objc set(barTintColor)
  }
  @objc public var barStyle: UIKit.UIBarStyle {
    @objc get
    @objc set(barStyle)
  }
  @objc public var translucent: Swift.Bool {
    @objc get
    @objc set(translucent)
  }
  @objc public var headerText: Swift.String {
    @objc get
    @objc set(headerText)
  }
  @objc public var buttonText: Swift.String {
    @objc get
    @objc set(buttonText)
  }
  @objc public var font: UIKit.UIFont? {
    @objc get
    @objc set(font)
  }
  @objc public var textColor: UIKit.UIColor? {
    @objc get
    @objc set(textColor)
  }
  @objc deinit
  @objc override dynamic public init()
}
public protocol FormValueItemStyle : Elements.TintableStyle {
  var separatorColor: UIKit.UIColor? { get }
  var title: Elements.TextStyle { get }
}
@_hasMissingDesignatedInitializers open class FormValueItem<ValueType, StyleType> : Elements.FormItem where ValueType : Swift.Equatable, StyleType : Elements.FormValueItemStyle {
  public var subitems: [Elements.FormItem] {
    get
  }
  public var identifier: Swift.String?
  public var value: ValueType {
    get
    set
  }
  public var publisher: Elements.Observable<ValueType>
  public var style: StyleType
  @Elements.Observable @_projectedValueProperty($title) public var title: Swift.String? {
    get
    set
    _modify
  }
  public var $title: Elements.Observable<Swift.String?> {
    get
  }
  open func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
open class PresentableInteractor<PresenterType> : Elements.Interactor {
  final public let presenter: PresenterType
  public init(presenter: PresenterType)
  @objc deinit
  override public init()
}
@_hasMissingDesignatedInitializers final public class FormSwitchItem : Elements.FormValueItem<Swift.Bool, Elements.FormSwitchItemStyle> {
  public init(style: Elements.FormSwitchItemStyle = FormSwitchItemStyle())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc final public class SubmitButton : UIKit.UIControl {
  public init(style: Elements.ButtonStyle)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var title: Swift.String? {
    get
    set
  }
  @objc override final public var accessibilityIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  final public var showsActivityIndicator: Swift.Bool {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct StoredCardConfiguration {
  public var showsSecurityCodeField: Swift.Bool
  public init()
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSTextFieldCustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSTextFieldCustomization
  @objc public var borderWidth: CoreGraphics.CGFloat {
    @objc get
    @objc set(borderWidth)
  }
  @objc public var borderColor: UIKit.UIColor {
    @objc get
    @objc set(borderColor)
  }
  @objc public var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set(cornerRadius)
  }
  @objc public var keyboardAppearance: UIKit.UIKeyboardAppearance {
    @objc get
    @objc set(keyboardAppearance)
  }
  @objc public var placeholderTextColor: UIKit.UIColor {
    @objc get
    @objc set(placeholderTextColor)
  }
  @objc public var font: UIKit.UIFont? {
    @objc get
    @objc set(font)
  }
  @objc public var textColor: UIKit.UIColor? {
    @objc get
    @objc set(textColor)
  }
  @objc deinit
  @objc override dynamic public init()
}
public protocol ElementsViewControllerPresentingDelegate : AnyObject {
  func requestToShow(viewController: UIKit.UIViewController)
  func requestToDismiss()
}
public protocol ElementsActionCompletionDelegate : AnyObject {
  func didFail(with error: Swift.Error, driver: Elements.ElementsActionDriver)
  func didSuccess(with token: Swift.String?, driver: Elements.ElementsActionDriver)
}
final public class ElementsActionDriver : Elements.Element {
  final public class Configuration {
    final public let environment: Elements.Environment
    final public let returnURLScheme: Swift.String
    final public let style: Elements.RedirectElementStyle?
    public init(environment: Elements.Environment, returnURLScheme: Swift.String, style: Elements.RedirectElementStyle? = nil)
    @objc deinit
  }
  weak final public var presentingDelegate: Elements.ElementsViewControllerPresentingDelegate?
  weak final public var completionDelegate: Elements.ElementsActionCompletionDelegate?
  public init(configuration: Elements.ElementsActionDriver.Configuration, completionDelegate: Elements.ElementsActionCompletionDelegate? = nil, presentingDelegate: Elements.ElementsViewControllerPresentingDelegate? = nil)
  final public func requestPaypalSetup()
  final public func requestKakaoPaySetup()
  final public func startPayment(type: Swift.String)
  @objc deinit
}
extension ElementsActionDriver : Elements.ActionElementDelegate {
  final public func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  final public func didComplete(from element: Elements.ActionElement)
  final public func didFail(with error: Swift.Error, from element: Elements.ActionElement)
}
extension ElementsActionDriver : Elements.PresentationDelegate {
  final public func present(element: Elements.PresentableElement)
}
@objc @_hasMissingDesignatedInitializers final public class ELEViewController : UIKit.UIViewController {
  public init(view: UIKit.UIView, title: Swift.String? = nil)
  @objc override final public func loadView()
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol Hidable {
  var isHidden: Elements.Observable<Swift.Bool> { get }
}
public protocol FormItem : AnyObject {
  var identifier: Swift.String? { get set }
  var subitems: [Elements.FormItem] { get }
  func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
}
extension FormItem {
  public var flatSubitems: [Elements.FormItem] {
    get
  }
}
public protocol ValidatableFormItem : Elements.FormItem {
  var validationFailureMessage: Swift.String? { get set }
  func isValid() -> Swift.Bool
}
public protocol InputViewRequiringFormItem : Elements.FormItem {
}
public struct FormElementStyle : Elements.TintableStyle {
  public var backgroundColor: UIKit.UIColor
  public var sectionHeader: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var `switch`: Elements.FormSwitchItemStyle
  public var hintLabel: Elements.TextStyle
  public var mainButtonItem: Elements.FormButtonItemStyle
  public var secondaryButtonItem: Elements.FormButtonItemStyle
  public var separatorColor: UIKit.UIColor? {
    get
    set
  }
  public var addressStyle: Elements.AddressStyle {
    get
  }
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.FormButtonItemStyle, secondaryButton: Elements.FormButtonItemStyle, helper: Elements.TextStyle, sectionHeader: Elements.TextStyle)
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.ButtonStyle, secondaryButton: Elements.ButtonStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
public struct SimpleScheduler : Elements.Scheduler {
  public init(maximumCount: Swift.Int)
  public func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public struct FormErrorItemStyle : Elements.ViewStyle {
  public var message: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var backgroundColor: UIKit.UIColor
  public init(message: Elements.TextStyle)
  public init()
}
@objc final public class ListItemView : UIKit.UIView, Elements.AnyFormItemView {
  final public var childItemViews: [Elements.AnyFormItemView]
  @objc dynamic public init()
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
open class BaseListCellModel : ElementsListKit.ListCellModel {
  public init(identifier: Swift.String? = nil)
  open var identifier: Swift.String {
    get
  }
  open var cellType: ElementsListKit.ListCollectionViewCell.Type {
    get
  }
  open func identical(to model: ElementsListKit.ListCellModel) -> Swift.Bool
  open func size(constrainedTo _: CoreGraphics.CGSize) -> ElementsListKit.ListCellSize
  @objc deinit
}
@_inheritsConvenienceInitializers open class BaseListCell<CellModelType> : ElementsListKit.ListCollectionViewCell where CellModelType : Elements.BaseListCellModel {
  public struct Constants {
  }
  open var model: CellModelType? {
    get
  }
  @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc override dynamic open func apply(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes)
  open func setup(renderProp: CellModelType, sizing: Swift.Bool)
  @objc final public func bindViewModel(_ viewModel: Any)
  final public func setup(renderProp: ElementsListKit.ListCellModel, sizing: Swift.Bool)
  @objc deinit
}
@_inheritsConvenienceInitializers open class FormValueItemView<ValueType, Style, ItemType> : Elements.FormItemView<ItemType>, Elements.AnyFormValueItemView where ValueType : Swift.Equatable, Style : Elements.FormValueItemStyle, ItemType : Elements.FormValueItem<ValueType, Style> {
  public var titleLabel: UIKit.UILabel {
    get
    set
  }
  required public init(item: ItemType)
  @objc override dynamic open func didAddSubview(_ subview: UIKit.UIView)
  open var isEditing: Swift.Bool {
    get
    set
  }
  open func validate()
  public var showsSeparator: Swift.Bool {
    get
    set
  }
  open func configureSeparatorView()
  @objc deinit
}
public protocol AnyFormValueItemView : Elements.AnyFormItemView {
  var isEditing: Swift.Bool { get set }
  func validate()
}
extension Array : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Array<Element>
}
extension ElementsScope where Base == [Elements.CardType] {
  public func types(forCardNumber cardNumber: Swift.String) -> [Elements.CardType]
  public func type(forCardNumber cardNumber: Swift.String) -> Elements.CardType?
}
open class AbstractPersonalInformationElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable {
  final public let paymentMethod: Elements.PaymentMethod
  weak public var delegate: Elements.PaymentElementDelegate?
  public var viewController: UIKit.UIViewController {
    get
    set
  }
  public var localizationParameters: Elements.LocalizationParameters?
  final public let style: Elements.FormElementStyle
  final public let requiresModalPresentation: Swift.Bool
  final public let configuration: Elements.AbstractPersonalInformationElement.Configuration
  public init(paymentMethod: Elements.PaymentMethod, configuration: Elements.AbstractPersonalInformationElement.Configuration, style: Elements.FormElementStyle = FormElementStyle())
  public var firstNameItem: Elements.FormTextInputItem? {
    get
  }
  public var lastNameItem: Elements.FormTextInputItem? {
    get
  }
  public var emailItem: Elements.FormTextInputItem? {
    get
  }
  public var phoneItem: Elements.FormPhoneNumberItem? {
    get
  }
  open func submitButtonTitle() -> Swift.String
  open func createPaymentDetails() -> Elements.PaymentMethodDetails
  open func getPhoneExtensions() -> [Elements.PhoneExtension]
  @objc deinit
}
public struct CardPaymentMethod : Elements.AnyCardPaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public let cardData: [Elements.SupportedCardData]
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, fundingSource: Elements.CardFundingSource?, cardData: [Elements.SupportedCardData])
}
public enum ThemeType {
  case light
  case dark
  public static func == (a: Elements.ThemeType, b: Elements.ThemeType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ElementsTheme : Elements.Theme {
  final public let type: Elements.ThemeType
  final public let identifier: Swift.String
  final public var uiPaddingUnit: CoreGraphics.CGFloat
  final public var themeChangeAnimDuration: Swift.Double
  final public let defaultInteractionAnimationDuration: Swift.Double
  final public var localizationParameter: Elements.LocalizationParameters?
  final public let screenWidth: CoreGraphics.CGFloat
  final public let screenHeight: CoreGraphics.CGFloat
  final public var colors: Elements.ColorSchema
  final public var fonts: Elements.FontSchema
  final public var images: Elements.ImageAssets
  public static let light: Elements.ElementsTheme
  public static let dark: Elements.ElementsTheme
  public static let variants: [Elements.ElementsTheme]
  public static let manager: Elements.ThemeManager<Elements.ElementsTheme>
  public init(identifier: Swift.String, type: Elements.ThemeType, colors: Elements.ColorSchema = LightThemeColors(), fonts: Elements.FontSchema = LightThemeFonts(), images: Elements.ImageAssets = LightThemeAssets())
  @objc deinit
}
public enum AppTheme {
  public static var current: Elements.ElementsTheme {
    get
  }
}
public protocol ListIdentifiable : Swift.Equatable {
  var diffIdentifier: ObjectiveC.NSObjectProtocol { get }
}
extension ListIdentifiable {
  public func diffable() -> ElementsListKit.ListDiffable
  public static func isDiffable(_ value: Any) -> Swift.Bool
  public init?(diffable: Any)
}
extension Sequence where Self.Element : Elements.ListIdentifiable {
  public func diffables() -> [ElementsListKit.ListDiffable]
}
extension UIProgressView {
  convenience public init(style: Elements.ProgressViewStyle)
}
public enum NavigationBarStyle {
  case mainTheme
  case white
  case dark
  case transparent
  public static func == (a: Elements.NavigationBarStyle, b: Elements.NavigationBarStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol NavigationControllerType : UIKit.UINavigationController, Elements.ViewControllable {
  var navigationBarStyle: Elements.NavigationBarStyle { get set }
}
@objc @_inheritsConvenienceInitializers open class NavigationController : UIKit.UINavigationController, Elements.NavigationControllerType {
  open var navigationBarStyle: Elements.NavigationBarStyle {
    get
    set
  }
  @objc override dynamic open func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool)
  public func replaceScreen(viewController: Elements.ViewControllable)
  @available(iOS 5.0, *)
  @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol DeviceDependant {
  static func isDeviceSupported() -> Swift.Bool
}
final public class Blocks {
  final public let configuration: Elements.Blocks.Configuration
  required public init(configuration: Elements.Blocks.Configuration)
  @objc deinit
}
extension Blocks {
  final public class Configuration {
    @_hasMissingDesignatedInitializers final public class CardConfiguration {
      final public var showsHolderNameField: Swift.Bool
      final public var showsStorePaymentMethodField: Swift.Bool
      final public var showsSecurityCodeField: Swift.Bool
      final public var billingAddress: Elements.CardElement.AddressFormType
      final public var stored: Elements.StoredCardConfiguration
      @objc deinit
    }
    final public class ApplePayConfiguration {
      final public var summaryItems: [PassKit.PKPaymentSummaryItem]
      final public var merchantIdentifier: Swift.String
      final public var merchantName: Swift.String
      final public var requiredBillingContactFields: Swift.Set<PassKit.PKContactField>
      final public var requiredShippingContactFields: Swift.Set<PassKit.PKContactField>
      final public var excludedCardNetworks: [PassKit.PKPaymentNetwork]
      public init(summaryItems: [PassKit.PKPaymentSummaryItem], merchantIdentifier: Swift.String, requiredBillingContactFields: Swift.Set<PassKit.PKContactField> = [], requiredShippingContactFields: Swift.Set<PassKit.PKContactField> = [])
      @objc deinit
    }
    final public let environment: Elements.Environment
    final public var card: Elements.Blocks.Configuration.CardConfiguration
    final public var applePay: Elements.Blocks.Configuration.ApplePayConfiguration?
    final public var localizationParameters: Elements.LocalizationParameters?
    final public var payment: Elements.Payment?
    public init(environment: Elements.Environment, localizationParameters: Elements.LocalizationParameters? = nil, applePay: Elements.Blocks.Configuration.ApplePayConfiguration? = nil)
    @objc deinit
  }
}
extension ApplePayElement : PassKit.PKPaymentAuthorizationViewControllerDelegate {
  @objc dynamic public func paymentAuthorizationViewControllerDidFinish(_ controller: PassKit.PKPaymentAuthorizationViewController)
  @objc dynamic public func paymentAuthorizationViewController(_ controller: PassKit.PKPaymentAuthorizationViewController, didAuthorizePayment payment: PassKit.PKPayment, completion: @escaping (PassKit.PKPaymentAuthorizationStatus) -> Swift.Void)
}
extension ApplePayElement {
  public struct Configuration {
    public var payment: Elements.Payment
    public let paymentMethod: Elements.ApplePayPaymentMethod
    public var summaryItems: [PassKit.PKPaymentSummaryItem]
    public var merchantIdentifier: Swift.String
    public var merchantName: Swift.String
    public var requiredBillingContactFields: Swift.Set<PassKit.PKContactField>
    public var requiredShippingContactFields: Swift.Set<PassKit.PKContactField>
    public init(payment: Elements.Payment, paymentMethod: Elements.ApplePayPaymentMethod, summaryItems: [PassKit.PKPaymentSummaryItem], merchantIdentifier: Swift.String, merchantName: Swift.String, requiredBillingContactFields: Swift.Set<PassKit.PKContactField> = [], requiredShippingContactFields: Swift.Set<PassKit.PKContactField> = [])
  }
}
public protocol Details : Swift.Encodable {
}
extension Details {
  public var encodable: Elements.AnyEncodable {
    get
  }
}
public protocol PaymentMethodDetails : Elements.Details {
}
public protocol AdditionalDetails : Elements.Details {
}
extension Details {
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
}
public struct CountryCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct ProgressViewStyle : Elements.ViewStyle {
  public let progressTintColor: UIKit.UIColor
  public let trackTintColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public init(progressTintColor: UIKit.UIColor, trackTintColor: UIKit.UIColor)
}
public protocol AnyAPIServiceProvider : Elements.Element {
  func chargeTransaction(data: Elements.ChargeData, completion: @escaping (Swift.Result<Elements.ChargeAPIResponse, Swift.Error>) -> Swift.Void)
  func handleCreatePayment(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.CreatePaymentMethodResponse, Swift.Error>) -> Swift.Void)
  func handleTokenizeCard(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  func handleTokenizeApplePay(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  func handlePaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  func fetchPaymentMethods(completion: @escaping (Swift.Result<Elements.PaymentMethods, Swift.Error>) -> Swift.Void)
}
public class APIServiceProvider : Elements.AnyAPIServiceProvider {
  public init(environment: Elements.Environment)
  public func chargeTransaction(data: Elements.ChargeData, completion: @escaping (Swift.Result<Elements.ChargeAPIResponse, Swift.Error>) -> Swift.Void)
  public func handleCreatePayment(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.CreatePaymentMethodResponse, Swift.Error>) -> Swift.Void)
  public func handleTokenizeCard(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func handleTokenizeApplePay(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func handlePaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  public func fetchPaymentMethods(completion: @escaping (Swift.Result<Elements.PaymentMethods, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol AnyRetryAPIClient : Elements.APIClientProtocol {
  typealias ShouldRetryHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Bool
  func perform<R>(_ request: R, shouldRetry: Self.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class RetryAPIClient : Elements.AnyRetryAPIClient {
  public init(apiClient: Elements.APIClientProtocol, scheduler: Elements.Scheduler)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  final public func perform<R>(_ request: R, shouldRetry: Elements.RetryAPIClient.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
public protocol FormItemInjector {
  func inject(into formViewController: Elements.FormViewController)
}
final public class FormErrorItem : Elements.FormItem, Elements.Hidable {
  @Elements.Observable @_projectedValueProperty($message) final public var message: Swift.String? {
    get
    set
    _modify
  }
  final public var $message: Elements.Observable<Swift.String?> {
    get
  }
  final public let iconName: Swift.String
  final public let style: Elements.FormErrorItemStyle
  final public var identifier: Swift.String?
  final public var isHidden: Elements.Observable<Swift.Bool>
  final public var subitems: [Elements.FormItem]
  public init(message: Swift.String? = nil, iconName: Swift.String, style: Elements.FormErrorItemStyle = FormErrorItemStyle())
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_inheritsConvenienceInitializers open class BaseFormPickerItemView<T> : Elements.FormValueItemView<Elements.BasePickerElement<T>, Elements.FormTextItemStyle, Elements.BaseFormPickerItem<T>>, UIKit.UIPickerViewDelegate, UIKit.UIPickerViewDataSource where T : Swift.CustomStringConvertible, T : Swift.Equatable {
  required public init(item: Elements.BaseFormPickerItem<T>)
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent element: Swift.Int) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, titleForRow row: Swift.Int, forComponent element: Swift.Int) -> Swift.String?
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent element: Swift.Int)
  @objc deinit
}
public enum ElementError : Swift.Error {
  case cancelled
  case redirectTokenDoesNotExsits
  case paymentMethodNotSupported
  public static func == (a: Elements.ElementError, b: Elements.ElementError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class WalletsElement : Elements.PaymentElement, Elements.PresentableElement, Elements.LoadingElement {
  final public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak final public var walletsDelegate: Elements.WalletsElementDelegate?
  weak final public var delegate: Elements.PaymentElementDelegate?
  final public let style: Elements.ListElementStyle
  public init(paymentMethod: Elements.WalletsPaymentMethod, style: Elements.ListElementStyle = ListElementStyle())
  final public var viewController: UIKit.UIViewController {
    get
  }
  final public func stopLoading()
  final public var requiresModalPresentation: Swift.Bool
  @objc deinit
}
extension WalletsElement : Elements.TrackableElement {
}
public protocol WalletsElementDelegate : AnyObject {
  func didSelect(_ paymentMethod: Elements.PaymentMethod, in walletsElement: Elements.WalletsElement)
}
public protocol ViewableRouting : Elements.Routing {
  var viewControllable: Elements.ViewControllable { get }
  var uiRoutable: Elements.UIRoutable? { get }
}
open class ViewableRouter<InteractorType, ViewControllerType> : Elements.Router<InteractorType>, Elements.ViewableRouting {
  final public let viewController: ViewControllerType
  final public let viewControllable: Elements.ViewControllable
  final public let uiRoutable: Elements.UIRoutable?
  public init(interactor: InteractorType, viewController: ViewControllerType, uiRoutable: Elements.UIRoutable? = UIRouter())
  @objc deinit
  override public init(interactor: InteractorType)
}
public protocol ViewControllable : Elements.RouterPresentable {
  var uiviewController: UIKit.UIViewController { get }
}
extension ViewControllable where Self : UIKit.UIViewController {
  public var uiviewController: UIKit.UIViewController {
    get
  }
}
@_hasMissingDesignatedInitializers public class Analytics {
  public enum Flavor : Swift.String {
    case elements, dropin
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Event {
    public var element: Swift.String
    public var flavor: Elements.Analytics.Flavor
    public var environment: Elements.Environment
    public init(element: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  }
  public static var isEnabled: Swift.Bool
  public static func sendEvent(element: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  @objc deinit
}
final public class ThemeManager<T> where T : Elements.Theme {
  final public var observers: Foundation.NSHashTable<Swift.AnyObject>
  final public var activeTheme: T {
    get
    set
  }
  public init(default theme: T, persistor: Elements.ThemePersistor = UserDefaults.standard, forceDefault: Swift.Bool = false)
  @objc deinit
}
public enum CancelButtonStyle {
  case system
  case legacy
  case custom(UIKit.UIImage)
}
public enum ToolbarMode {
  case leftCancel
  case rightCancel
  case natural
  public static func == (a: Elements.ToolbarMode, b: Elements.ToolbarMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct NavigationStyle {
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public var tintColor: UIKit.UIColor?
  public var cornerRadius: CoreGraphics.CGFloat
  public var barTitle: Elements.TextStyle
  public var cancelButton: Elements.CancelButtonStyle
  public var toolbarMode: Elements.ToolbarMode
  public init()
}
final public class FormSplitItem : Elements.FormItem {
  final public let style: Elements.ViewStyle
  final public var identifier: Swift.String?
  final public var subitems: [Elements.FormItem] {
    get
  }
  public init(items: Elements.FormItem..., style: Elements.ViewStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_hasMissingDesignatedInitializers open class FormTextItem : Elements.FormValueItem<Swift.String, Elements.FormTextItemStyle>, Elements.ValidatableFormItem, Elements.InputViewRequiringFormItem {
  @Elements.Observable @_projectedValueProperty($placeholder) public var placeholder: Swift.String? {
    get
    set
    _modify
  }
  public var $placeholder: Elements.Observable<Swift.String?> {
    get
  }
  public var formatter: Elements.Formatter?
  public var validator: Elements.Validator?
  public var validationFailureMessage: Swift.String?
  public var autocapitalizationType: UIKit.UITextAutocapitalizationType
  public var autocorrectionType: UIKit.UITextAutocorrectionType
  public var keyboardType: UIKit.UIKeyboardType
  public var contentType: UIKit.UITextContentType?
  public init(style: Elements.FormTextItemStyle)
  public func isValid() -> Swift.Bool
  @objc deinit
}
public protocol Scheduler {
  func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public protocol ViewStyle {
  var backgroundColor: UIKit.UIColor { get set }
}
public protocol TintableStyle : Elements.ViewStyle {
  var tintColor: UIKit.UIColor? { get set }
}
@_inheritsConvenienceInitializers final public class FormTextInputItemView : Elements.FormTextItemView<Elements.FormTextInputItem> {
  required public init(item: Elements.FormTextInputItem)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CardNumberFormatter : Elements.NumericFormatter {
  final public var cardType: Elements.CardType?
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  override public init()
  @objc deinit
}
public enum RouterLifecycle {
  case didLoad
  public static func == (a: Elements.RouterLifecycle, b: Elements.RouterLifecycle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol RouterScope : AnyObject {
}
public protocol Routing : Elements.RouterScope {
  var interactable: Elements.Interactable { get }
  var children: [Elements.Routing] { get }
  func load()
  func attachChild(_ child: Elements.Routing)
  func detachChild(_ child: Elements.Routing)
}
open class Router<InteractorType> : Elements.Routing {
  final public let interactor: InteractorType
  final public let interactable: Elements.Interactable
  final public var children: [Elements.Routing]
  public init(interactor: InteractorType)
  final public func load()
  open func didLoad()
  final public func attachChild(_ child: Elements.Routing)
  final public func detachChild(_ child: Elements.Routing)
  @objc deinit
}
@objc public protocol ElementsAuthenticationContext : AnyObject {
  @objc func elementsAuthHostController() -> UIKit.UIViewController
  @objc optional func authContextWillAppear()
  @objc optional func authContextWillDisappear()
}
public protocol ElementsAPIClientType : AnyObject {
  func tokenizeCard(data: Elements.ElementsCardParams, authContext: Elements.ElementsAuthenticationContext?, idempotencyKey: Swift.String, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  func performPaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, config: Elements.PaymentSetupModel, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
}
public class ElementsAPIClientConfiguration {
  final public let environment: Elements.Environment
  final public let stripePublishableKey: Swift.String?
  public init(environment: Elements.Environment, stripePublishableKey: Swift.String? = nil)
  @objc deinit
}
@objc public class ElementsAPIClient : ObjectiveC.NSObject, Elements.ElementsAPIClientType {
  public init(config: Elements.ElementsAPIClientConfiguration)
  public func tokenizeCard(data: Elements.ElementsCardParams, authContext: Elements.ElementsAuthenticationContext? = nil, idempotencyKey: Swift.String = UUID().uuidString, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func tokenizeApplePay(applePayToken: Elements.ApplePayDetails, idempotencyKey: Swift.String = UUID().uuidString, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func performPaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, config: Elements.PaymentSetupModel, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
extension ElementsScope where Base : UIKit.UIView {
  public func round(corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, precentage: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, rounding: Elements.CornerRounding)
  public func round(using rounding: Elements.CornerRounding)
}
public struct ElementsAPIError : Swift.Decodable, Swift.Error, Foundation.LocalizedError {
  public var status: Swift.Int?
  public let errorCode: Swift.String
  public let errorMessage: Swift.String
  public let type: Elements.APIErrorType
  public var errorDescription: Swift.String? {
    get
  }
  public init(status: Swift.Int?, errorCode: Swift.String, errorMessage: Swift.String, type: Elements.APIErrorType)
  public init(from decoder: Swift.Decoder) throws
}
public enum APIErrorType : Swift.String, Swift.Decodable {
  case cardError
  case apiError
  case authenticationError
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UILabel {
  convenience public init(style: Elements.TextStyle)
}
public struct RedirectElementStyle {
  public let preferredBarTintColor: UIKit.UIColor?
  public let preferredControlTintColor: UIKit.UIColor
  public let modalPresentationStyle: UIKit.UIModalPresentationStyle
  public init(preferredBarTintColor: UIKit.UIColor? = nil, preferredControlTintColor: UIKit.UIColor = .systemBlue, modalPresentationStyle: UIKit.UIModalPresentationStyle = .formSheet)
}
public protocol ThemePersistor {
  func retreiveThemeId() -> Swift.String?
  func saveThemeId(_ identifier: Swift.String)
}
extension UserDefaults : Elements.ThemePersistor {
  public func retreiveThemeId() -> Swift.String?
  public func saveThemeId(_ identifier: Swift.String)
}
@objc public class InteractivePopRecognizer : ObjectiveC.NSObject, UIKit.UIGestureRecognizerDelegate {
  public var navigationController: UIKit.UINavigationController
  public init(controller: UIKit.UINavigationController)
  @objc public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
final public class FormPhoneNumberItem : Elements.FormTextItem {
  final public var prefix: Swift.String {
    get
  }
  final public var phoneNumber: Swift.String {
    get
  }
  public init(selectableValues: [Elements.PhoneExtensionPickerItem], style: Elements.FormTextItemStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  override public init(style: Elements.FormTextItemStyle)
  @objc deinit
}
public protocol Buildable : AnyObject {
}
open class Builder<DependencyType> : Elements.Buildable {
  final public let dependency: DependencyType
  public init(dependency: DependencyType)
  @objc deinit
}
extension URL {
  public var queryParameters: [Swift.String : Swift.String] {
    get
  }
  public var isHttp: Swift.Bool {
    get
  }
}
public struct Payment {
  public struct Amount {
    public var value: Swift.Int
    public var currencyCode: Swift.String
    public init(value: Swift.Int, currencyCode: Swift.String)
    public init(value: Foundation.Decimal, currencyCode: Swift.String)
  }
  public var amount: Elements.Payment.Amount
  public var countryCode: Swift.String?
  public init(amount: Elements.Payment.Amount, countryCode: Swift.String? = nil)
}
extension Payment.Amount {
  public var formatted: Swift.String {
    get
  }
}
public protocol PickerElement : Swift.CustomStringConvertible, Swift.Equatable {
  var identifier: Swift.String { get }
}
public struct BasePickerElement<ElementType> : Elements.PickerElement where ElementType : Swift.CustomStringConvertible {
  public let identifier: Swift.String
  public let element: ElementType
  public static func == (lhs: Elements.BasePickerElement<ElementType>, rhs: Elements.BasePickerElement<ElementType>) -> Swift.Bool
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class BaseFormPickerItem<ElementType> : Elements.FormValueItem<Elements.BasePickerElement<ElementType>, Elements.FormTextItemStyle>, Elements.InputViewRequiringFormItem where ElementType : Swift.CustomStringConvertible {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class ListItemCell : UIKit.UITableViewCell {
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CardExpiryDateValidator : Elements.Validator {
  public init()
  final public func isValid(_ string: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public struct IssuerListPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let issuers: [Elements.IssuerListPaymentMethod.Issuer]
  public struct Issuer : Swift.Decodable {
    public let identifier: Swift.String
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
}
extension ListCollectionContext {
  public func dequeueReusableCell<T>(withReuseIdentifier reuseIdentifier: Swift.String, for sectionController: ElementsListKit.ListSectionController, at index: Swift.Int) -> T where T : UIKit.UICollectionViewCell
  public func dequeueReusableCell<T>(for sectionController: ElementsListKit.ListSectionController, at index: Swift.Int) -> T where T : UIKit.UICollectionViewCell
  public func dequeueReusableCell<T>(withNibName nibName: Swift.String, bundle: Foundation.Bundle?, for sectionController: ElementsListKit.ListSectionController, at index: Swift.Int) -> T where T : UIKit.UICollectionViewCell
  public func dequeueReusableCellFromStoryboard<T>(withIdentifier reuseIdentifier: Swift.String, for sectionController: ElementsListKit.ListSectionController, at index: Swift.Int) -> T where T : UIKit.UICollectionViewCell
  public func dequeueReusableSupplementaryView<T>(ofKind elementKind: Swift.String, forSectionController sectionController: ElementsListKit.ListSectionController, atIndex index: ObjectiveC.NSInteger) -> T where T : UIKit.UICollectionReusableView
  public func dequeueReusableSupplementaryViewFromStoryboard<T>(ofKind elementKind: Swift.String, withIdentifier identifier: Swift.String, forSectionController sectionController: ElementsListKit.ListSectionController, atIndex index: Swift.Int) -> T where T : UIKit.UICollectionReusableView
  public func dequeueReusableSupplementaryView<T>(ofKind elementKind: Swift.String, forSectionController sectionController: ElementsListKit.ListSectionController, nibName: Swift.String, bundle: Foundation.Bundle?, atIndex index: Swift.Int) -> T where T : UIKit.UICollectionReusableView
}
@_hasMissingDesignatedInitializers final public class ElementsSDKVersion {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class STPThreeDSFooterCustomization : ObjectiveC.NSObject {
  @objc public class func defaultSettings() -> Elements.STPThreeDSFooterCustomization
  @objc public var backgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var chevronColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var headingTextColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var headingFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @objc public var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @objc public var textColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init()
}
public struct VaultTokens {
  public let elementsToken: Elements.ElementsToken?
  public let fallbackStripeToken: Elements.StripeVaultToken?
}
public enum TokenizationStatus : Swift.String, Swift.Codable {
  case unknown
  case requiresPaymentMethod
  case requiresConfirmation
  case requiresAction
  case processing
  case succeeded
  case canceled
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct TokenizationResponse : Elements.Response {
  public let token: Swift.String
  public let status: Elements.TokenizationStatus
  public let card: Elements.ElementsCardResponse?
  public init(from decoder: Swift.Decoder) throws
}
final public class IBANFormatter : Elements.Formatter {
  public init()
  final public func formattedValue(for value: Swift.String) -> Swift.String
  final public func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol Localizable {
  var localizationParameters: Elements.LocalizationParameters? { get set }
}
public protocol Cancellable : AnyObject {
  func didCancel()
}
public protocol PresentableElement : Elements.Element {
  var requiresModalPresentation: Swift.Bool { get }
  var viewController: UIKit.UIViewController { get }
}
extension PresentableElement {
  public var requiresModalPresentation: Swift.Bool {
    get
  }
}
public protocol TrackableElement : Elements.Element, Elements.PaymentMethodAware, Elements.ViewControllerDelegate {
}
extension TrackableElement {
  public func viewDidLoad(viewController: UIKit.UIViewController)
  public func viewDidAppear(viewController: UIKit.UIViewController)
}
public typealias STPVoidBlock = () -> Swift.Void
public typealias STPBooleanSuccessBlock = (Swift.Bool, Swift.Error?) -> Swift.Void
open class LengthValidator : Elements.Validator {
  open var minimumLength: Swift.Int?
  open var maximumLength: Swift.Int?
  public init(minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  open func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
  @objc deinit
}
public struct RedirectPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public init(type: Swift.String, name: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers final public class SecuredViewController : UIKit.UIViewController {
  weak final public var delegate: Elements.ViewControllerDelegate?
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc override final public var title: Swift.String? {
    @objc get
    @objc set
  }
  public init(child: UIKit.UIViewController, style: Elements.ViewStyle)
  @objc deinit
  @objc override final public func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol BasePresenterOutput : AnyObject {
  func showNetworkRequestError(message: Swift.String?)
  func showNetworkSuccess(message: Swift.String?)
  func hideMessageErrorView()
  func showLoadingView()
  func hideLoadingView(completion: Elements.VoidCompletion?)
}
public protocol Presentable : AnyObject {
  func presentNetworkRequestError(message: Swift.String?)
  func presentNetworkSuccess(message: Swift.String?)
  func dismissMessageErrorView()
  func presentLoadingView()
  func dismissLoadingView(completion: Elements.VoidCompletion?)
}
open class Presenter<ViewControllerType> : Elements.Presentable {
  final public let viewController: ViewControllerType
  final public let viewControllable: Elements.ViewControllable?
  public init(viewController: ViewControllerType)
  public func presentNetworkSuccess(message: Swift.String?)
  public func presentNetworkRequestError(message: Swift.String?)
  public func dismissMessageErrorView()
  public func presentLoadingView()
  public func dismissLoadingView(completion: Elements.VoidCompletion?)
  @objc deinit
}
public struct UnknownError : Swift.Error, Foundation.LocalizedError {
  public var errorDescription: Swift.String?
  public init(errorDescription: Swift.String? = nil)
}
extension ListSingleSectionController {
  convenience public init<Item, Cell>(configure: @escaping (Item, Cell) -> Swift.Void, size: @escaping (Item, ElementsListKit.ListCollectionContext?) -> CoreGraphics.CGSize) where Cell : UIKit.UICollectionViewCell
  convenience public init<Value, Cell>(configure: @escaping (Value, Cell) -> Swift.Void, size: @escaping (Value, ElementsListKit.ListCollectionContext?) -> CoreGraphics.CGSize) where Value : Elements.ListIdentifiable, Cell : UIKit.UICollectionViewCell
}
public enum CardType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case accel
  case alphaBankBonusMasterCard
  case alphaBankBonusVISA
  case argencard
  case americanExpress
  case bcmc
  case bijenkorfCard
  case cabal
  case carteBancaire
  case cencosud
  case chequeDejeneur
  case chinaUnionPay
  case codensa
  case creditUnion24
  case dankort
  case dankortVISA
  case diners
  case discover
  case elo
  case forbrugsforeningen
  case hiper
  case hipercard
  case jcb
  case karenMillen
  case kcp
  case laser
  case maestro
  case maestroUK
  case masterCard
  case mir
  case naranja
  case netplus
  case nyce
  case oasis
  case pulse
  case shopping
  case solo
  case star
  case troy
  case uatp
  case visa
  case warehouse
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [Elements.CardType]
  public static var allCases: [Elements.CardType] {
    get
  }
}
public protocol PaymentMethod : Swift.Decodable {
  var type: Swift.String { get }
  var name: Swift.String { get }
  var displayInformation: Elements.DisplayInformation { get }
  func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
}
public struct DisplayInformation {
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var brandIconURL: Foundation.URL?
}
extension DisplayInformation : Swift.Equatable {
  public static func == (a: Elements.DisplayInformation, b: Elements.DisplayInformation) -> Swift.Bool
}
extension PaymentMethod {
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using _: Elements.LocalizationParameters?) -> Elements.DisplayInformation
}
public struct ActionElementData {
  public let details: Elements.AdditionalDetails
  public let paymentData: Swift.String?
  public init(details: Elements.AdditionalDetails, paymentData: Swift.String?)
}
open class MultiStageComponentizedBuilder<Component, Router, DynamicBuildDependency> : Elements.Buildable {
  public var componentForCurrentBuildPass: Component {
    get
  }
  public init(componentBuilder: @escaping () -> Component)
  final public func finalStageBuild(withDynamicDependency dynamicDependency: DynamicBuildDependency) -> Router
  open func finalStageBuild(with component: Component, _ dynamicDependency: DynamicBuildDependency) -> Router
  @objc deinit
}
@_inheritsConvenienceInitializers open class SimpleMultiStageComponentizedBuilder<Component, Router> : Elements.MultiStageComponentizedBuilder<Component, Router, ()> {
  override public init(componentBuilder: @escaping () -> Component)
  final override public func finalStageBuild(with component: Component, _ dynamicDependency: ()) -> Router
  open func finalStageBuild(with component: Component) -> Router
  final public func finalStageBuild() -> Router
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class MoneyTextField : UIKit.UIControl, UIKit.UITextViewDelegate {
  open var amount: Swift.UInt {
    get
    set(newAmount)
  }
  open var currency: Swift.String {
    get
    set
  }
  open var amountString: Swift.String {
    get
  }
  open var usesGroupingSeparator: Swift.Bool {
    get
    set
  }
  open var borderColor: UIKit.UIColor {
    get
    set
  }
  open var borderWidth: CoreGraphics.CGFloat {
    get
    set
  }
  open var cornerRadius: CoreGraphics.CGFloat {
    get
    set
  }
  open var largeFont: UIKit.UIFont {
    get
    set
  }
  open var smallFont: UIKit.UIFont {
    get
    set
  }
  open var numberColor: UIKit.UIColor {
    get
    set
  }
  open var currencySymbolColor: UIKit.UIColor {
    get
    set
  }
  @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  open var inset: CoreGraphics.CGFloat
  public init(amount: Swift.UInt, currency: Swift.String)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic open func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc open func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class CopyLabelView : UIKit.UIView, Elements.Localizable {
  final public var localizationParameters: Elements.LocalizationParameters?
  public init(text: Swift.String, style: Elements.TextStyle)
  @objc deinit
  @objc override final public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override final public func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
final public class StripeAPIClient {
  public typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  public init(publishableKey: Swift.String, stripeAccount: Swift.String?)
  final public func perform<R>(_ request: R, parameters: [Swift.String : Any], completionHandler: @escaping Elements.StripeAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@objc public class StripeAppInfo : ObjectiveC.NSObject {
  public init(name: Swift.String, partnerId: Swift.String?, version: Swift.String?, url: Swift.String?)
  public var name: Swift.String {
    get
  }
  public var partnerId: Swift.String? {
    get
  }
  public var version: Swift.String? {
    get
  }
  public var url: Swift.String? {
    get
  }
  @objc deinit
  @objc override dynamic public init()
}
public struct PaymentSetupModel : Swift.Codable {
  public let returnURL: Swift.String
  public let cancelURL: Swift.String
  public init(returnURLScheme: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PaymentsSetupRequest : Elements.Request {
  public typealias ResponseType = Elements.PaymentsResponse
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
  public init(data: Elements.PaymentElementData, encodedToken: Swift.String?, config: Elements.PaymentSetupModel)
}
public struct BrowserInfo : Swift.Encodable {
  public var userAgent: Swift.String? {
    get
  }
  public static func initialize(completion: @escaping ((Elements.BrowserInfo?) -> Swift.Void))
  public func encode(to encoder: Swift.Encoder) throws
}
extension ElementsScope where Base : UIKit.UIView {
  @discardableResult
  public func anchore(inside view: UIKit.UIView, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func anchore(inside margines: UIKit.UILayoutGuide, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  public func wrapped(with insets: UIKit.UIEdgeInsets = .zero) -> UIKit.UIView
}
@_inheritsConvenienceInitializers final public class CardExpiryDateFormatter : Elements.NumericFormatter {
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  override public init()
  @objc deinit
}
public struct Environment : Elements.APIEnvironment {
  public var baseURL: Foundation.URL
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public var queryParameters: [Foundation.URLQueryItem]
  public let clientToken: Swift.String
  public static func sandbox(clientToken: Swift.String) -> Elements.Environment
  public static func portForward(clientToken: Swift.String) -> Elements.Environment
  public static func production(clientToken: Swift.String) -> Elements.Environment
  public static let unknown: Elements.Environment
  public init(baseURL: Foundation.URL? = nil, clientToken: Swift.String)
}
final public class ElementsActionHandler : Elements.ActionElement, Elements.Localizable {
  weak final public var delegate: Elements.ActionElementDelegate?
  weak final public var presentationDelegate: Elements.PresentationDelegate?
  final public var redirectElementStyle: Elements.RedirectElementStyle?
  final public var localizationParameters: Elements.LocalizationParameters?
  public init()
  final public func handle(_ action: Elements.Action)
  @objc deinit
}
@objc open class BaseTableViewController : Elements.BaseViewController, UIKit.UITableViewDataSource, UIKit.UITableViewDelegate {
  final public let style: Elements.ListElementStyle
  final public let tableView: UIKit.UITableView
  public init(style: Elements.ListElementStyle = ListElementStyle())
  @objc required convenience dynamic public init?(coder _: Foundation.NSCoder)
  public var sections: [Elements.ListItemsSection] {
    get
    set
  }
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  public func startLoading(for item: Elements.ListItem)
  public func stopLoading()
  open func setupTableViewAndConstraints()
  @objc public func numberOfSections(in _: UIKit.UITableView) -> Swift.Int
  @objc public func tableView(_: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc public func tableView(_: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc public func tableView(_ tableView: UIKit.UITableView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  @objc public func tableView(_: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForFooterInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
  @objc override dynamic public init()
}
public struct CardBrand : Swift.Decodable {
  public let type: Elements.CardType
  public let isSupported: Swift.Bool
  public enum CVCPolicy : Swift.String, Swift.Decodable {
    case required
    case optional
    case hidden
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(from decoder: Swift.Decoder) throws
}
extension CardBrand : Swift.Equatable {
  public static func == (a: Elements.CardBrand, b: Elements.CardBrand) -> Swift.Bool
}
public struct SupportedCardData : Swift.Decodable {
  public let brand: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case brand
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(brand: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
extension String : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.String
}
extension Optional : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Optional<Wrapped>
}
extension ElementsScope where Base == Swift.String? {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
extension ElementsScope where Base == Swift.String {
  public var nilIfEmpty: Swift.String? {
    get
  }
  public func truncate(to length: Swift.Int) -> Swift.String
  public func elements(withLengths lengths: [Swift.Int]) -> [Swift.String]
  public func elements(withLength length: Swift.Int) -> [Swift.String]
  public subscript(position: Swift.Int) -> Swift.String {
    get
  }
  public subscript(range: Swift.Range<Swift.Int>) -> Swift.String {
    get
  }
  public subscript(range: Swift.ClosedRange<Swift.Int>) -> Swift.String {
    get
  }
}
public struct FormSwitchItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var tintColor: UIKit.UIColor?
  public var separatorColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
public enum Coder {
  public static func decode<T>(_ data: Foundation.Data) throws -> T where T : Swift.Decodable
  public static func decode<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func decodeBase64<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  public static func encode<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
  public static func encodeBase64<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
}
public enum CornerRounding {
  case none
  case fixed(CoreGraphics.CGFloat)
  case percent(CoreGraphics.CGFloat)
}
extension CornerRounding : Swift.Equatable {
  public static func == (lhs: Elements.CornerRounding, rhs: Elements.CornerRounding) -> Swift.Bool
}
public protocol EventPublisher : AnyObject {
  associatedtype Event
  var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Self.Event>] { get set }
}
extension EventPublisher {
  public func addEventHandler(_ eventHandler: @escaping Elements.EventHandler<Self.Event>) -> Elements.EventHandlerToken
  public func removeEventHandler(with token: Elements.EventHandlerToken)
  public func publish(_ event: Self.Event)
}
public typealias EventHandler<Event> = (Event) -> Swift.Void
public struct EventHandlerToken : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Elements.EventHandlerToken, b: Elements.EventHandlerToken) -> Swift.Bool
}
public typealias VoidCompletion = (() -> Swift.Void)
public protocol RouterPresentable {
  func toPresentable() -> UIKit.UIViewController
}
extension UIViewController : Elements.RouterPresentable {
  public func toPresentable() -> UIKit.UIViewController
}
public protocol UIRoutable : Elements.RouterPresentable {
  var navigationController: Elements.NavigationControllerType { get }
  var hasRootController: Swift.Bool { get }
  func present(_ module: Elements.RouterPresentable, animated: Swift.Bool, fullScreen: Swift.Bool)
  func dismissModule(animated: Swift.Bool, completion: Elements.VoidCompletion?)
  func push(_ module: Elements.RouterPresentable, animated: Swift.Bool, completion: (() -> Swift.Void)?)
  func popModule(animated: Swift.Bool)
  func setRootModule(_ module: Elements.RouterPresentable, hideNavBar: Swift.Bool)
  func popToRootModule(animated: Swift.Bool)
}
@objc final public class UIRouter : ObjectiveC.NSObject, Elements.UIRoutable {
  final public var rootViewController: UIKit.UIViewController? {
    get
  }
  final public var hasRootController: Swift.Bool {
    get
  }
  final public let navigationController: Elements.NavigationControllerType
  public init(navigationController: Elements.NavigationControllerType = AppNavigationController())
  final public func present(_ module: Elements.RouterPresentable, animated: Swift.Bool = true, fullScreen: Swift.Bool = true)
  final public func dismissModule(animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  final public func push(_ module: Elements.RouterPresentable, animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  final public func popModule(animated: Swift.Bool = true)
  final public func setNavigationBarStyle(style: Elements.NavigationBarStyle, preferLargeTitles: Swift.Bool = false)
  final public func setRootModule(_ module: Elements.RouterPresentable, hideNavBar: Swift.Bool = true)
  final public func popToRootModule(animated: Swift.Bool)
  final public func toPresentable() -> UIKit.UIViewController
  @objc override dynamic public init()
  @objc deinit
}
extension UIRouter : UIKit.UINavigationControllerDelegate {
  @objc final public func navigationController(_ navigationController: UIKit.UINavigationController, didShow viewController: UIKit.UIViewController, animated: Swift.Bool)
}
public struct StripeVaultToken : Elements.Response {
  public let id: Swift.String
  public let type: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
extension Elements.ApplePayElement.Error : Swift.Equatable {}
extension Elements.ApplePayElement.Error : Swift.Hashable {}
extension Elements.KeyboardState : Swift.Equatable {}
extension Elements.KeyboardState : Swift.Hashable {}
extension Elements.BaseViewControllerStyle : Swift.Equatable {}
extension Elements.BaseViewControllerStyle : Swift.Hashable {}
extension Elements.RedirectElement.Error : Swift.Equatable {}
extension Elements.RedirectElement.Error : Swift.Hashable {}
extension Elements.BillingAddressFields : Swift.Equatable {}
extension Elements.BillingAddressFields : Swift.Hashable {}
extension Elements.BillingAddressFields : Swift.RawRepresentable {}
extension Elements.CardElement.AddressFormType : Swift.Equatable {}
extension Elements.CardElement.AddressFormType : Swift.Hashable {}
extension Elements.StoredPaymentMethodType : Swift.Equatable {}
extension Elements.StoredPaymentMethodType : Swift.Hashable {}
extension Elements.StoredPaymentMethodType : Swift.RawRepresentable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Equatable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Hashable {}
extension Elements.CardFundingSource : Swift.Equatable {}
extension Elements.CardFundingSource : Swift.Hashable {}
extension Elements.CardFundingSource : Swift.RawRepresentable {}
extension Elements.FullScreenWalletViewController : Elements.Presentable {}
extension Elements.FullScreenWalletViewController : Elements.ViewControllable {}
extension Elements.CardElement.Error : Swift.Equatable {}
extension Elements.CardElement.Error : Swift.Hashable {}
extension Elements.ShopperInteraction : Swift.Equatable {}
extension Elements.ShopperInteraction : Swift.Hashable {}
extension Elements.ShopperInteraction : Swift.RawRepresentable {}
extension Elements.STPThreeDSCustomizationButtonType : Swift.Equatable {}
extension Elements.STPThreeDSCustomizationButtonType : Swift.Hashable {}
extension Elements.STPThreeDSCustomizationButtonType : Swift.RawRepresentable {}
extension Elements.STPThreeDSButtonTitleStyle : Swift.Equatable {}
extension Elements.STPThreeDSButtonTitleStyle : Swift.Hashable {}
extension Elements.STPThreeDSButtonTitleStyle : Swift.RawRepresentable {}
extension Elements.PKPaymentMethodTypeWrapper : Swift.Equatable {}
extension Elements.PKPaymentMethodTypeWrapper : Swift.Hashable {}
extension Elements.PKPaymentMethodTypeWrapper : Swift.RawRepresentable {}
extension Elements.ImageResources : Swift.Equatable {}
extension Elements.ImageResources : Swift.Hashable {}
extension Elements.ImageResources : Swift.RawRepresentable {}
extension Elements.LogoURLProvider.Size : Swift.Equatable {}
extension Elements.LogoURLProvider.Size : Swift.Hashable {}
extension Elements.LogoURLProvider.Size : Swift.RawRepresentable {}
extension Elements.HTTPMethod : Swift.Equatable {}
extension Elements.HTTPMethod : Swift.Hashable {}
extension Elements.HTTPMethod : Swift.RawRepresentable {}
extension Elements.ThemeType : Swift.Equatable {}
extension Elements.ThemeType : Swift.Hashable {}
extension Elements.NavigationBarStyle : Swift.Equatable {}
extension Elements.NavigationBarStyle : Swift.Hashable {}
extension Elements.ElementError : Swift.Equatable {}
extension Elements.ElementError : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.Equatable {}
extension Elements.Analytics.Flavor : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.RawRepresentable {}
extension Elements.ToolbarMode : Swift.Equatable {}
extension Elements.ToolbarMode : Swift.Hashable {}
extension Elements.RouterLifecycle : Swift.Equatable {}
extension Elements.RouterLifecycle : Swift.Hashable {}
extension Elements.APIErrorType : Swift.Equatable {}
extension Elements.APIErrorType : Swift.Hashable {}
extension Elements.APIErrorType : Swift.RawRepresentable {}
extension Elements.TokenizationStatus : Swift.Equatable {}
extension Elements.TokenizationStatus : Swift.Hashable {}
extension Elements.TokenizationStatus : Swift.RawRepresentable {}
extension Elements.CardType : Swift.Equatable {}
extension Elements.CardType : Swift.Hashable {}
extension Elements.CardType : Swift.RawRepresentable {}
extension Elements.CardBrand.CVCPolicy : Swift.Equatable {}
extension Elements.CardBrand.CVCPolicy : Swift.Hashable {}
extension Elements.CardBrand.CVCPolicy : Swift.RawRepresentable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Equatable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Hashable {}
extension Elements.SupportedCardData.CodingKeys : Swift.RawRepresentable {}
