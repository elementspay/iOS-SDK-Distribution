// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Elements
import AVKit
import Accelerate
import CommonCrypto
import CoreGraphics
import CoreImage
import Darwin/*.fputs*/
@_exported import Elements
import Foundation
import ImageIO
import MobileCoreServices
import PassKit
import SafariServices
import Swift
import UIKit
import WebKit
public struct PaymentsResponse : Elements.Response {
  public let action: Elements.Action?
  public let token: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public protocol BillingAddressInformation {
  var billingAddress: Elements.AddressInfo? { get }
}
public struct PaymentElementData {
  public let paymentMethod: Elements.PaymentMethodDetails?
  public let storePaymentMethod: Swift.Bool
  public let browserInfo: Elements.BrowserInfo?
  public var billingAddress: Elements.AddressInfo? {
    get
  }
  public init(paymentMethodDetails: Elements.PaymentMethodDetails?, storePaymentMethod: Swift.Bool = false, browserInfo: Elements.BrowserInfo? = nil)
  public func dataByAddingBrowserInfo(completion: @escaping ((Elements.PaymentElementData) -> Swift.Void))
}
public struct CurrencyCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct AddressStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor? {
    get
  }
}
@objc public class ApplePayElement : ObjectiveC.NSObject, Elements.PresentableElement, Elements.PaymentElement, Elements.Localizable, Elements.FinalizableElement {
  public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak public var delegate: Elements.PaymentElementDelegate?
  public init(configuration: Elements.ApplePayElement.Configuration) throws
  public var viewController: UIKit.UIViewController {
    get
  }
  public var localizationParameters: Elements.LocalizationParameters?
  public func didFinalize(with success: Swift.Bool)
  @objc deinit
  @objc override dynamic public init()
}
extension ApplePayElement {
  public enum Error : Swift.Error, Foundation.LocalizedError {
    case userCannotMakePayment
    case deviceDoesNotSupportApplyPay
    case emptySummaryItems
    case negativeGrandTotal
    case invalidSummaryItem
    case invalidCountryCode
    case invalidCurrencyCode
    public var errorDescription: Swift.String? {
      get
    }
    public static func == (a: Elements.ApplePayElement.Error, b: Elements.ApplePayElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension DropInElement {
  public struct Style {
    public var navigation: Elements.NavigationStyle
    public var listElement: Elements.ListElementStyle
    public var formElement: Elements.FormElementStyle
    public var redirectElement: Elements.RedirectElementStyle?
    public var separatorColor: UIKit.UIColor? {
      get
      set
    }
    public init()
    public init(tintColor: UIKit.UIColor)
  }
}
public protocol ElementLoader : Elements.LoadingElement {
  func startLoading(for element: Elements.PaymentElement)
}
public protocol LoadingElement {
  func stopLoading()
}
public protocol Element : AnyObject {
  var environment: Elements.Environment { get set }
}
extension Element {
  public func finalizeIfNeeded(with success: Swift.Bool)
  public func cancelIfNeeded()
  public func stopLoadingIfNeeded()
}
public protocol FinalizableElement : Elements.Element {
  func didFinalize(with success: Swift.Bool)
}
extension Element {
  public var environment: Elements.Environment {
    get
    set
  }
  public var _isDropIn: Swift.Bool {
    get
    set
  }
}
public protocol DismissableElement : Elements.Element {
  func dismiss(_ animated: Swift.Bool, completion: (() -> Swift.Void)?)
}
final public class Elements {
  final public let configuration: Elements.DropInElement.PaymentMethodsConfiguration
  required public init(configuration: Elements.DropInElement.PaymentMethodsConfiguration)
  @_hasMissingDesignatedInitializers final public class DropIn {
    public static func create(configuration: Elements.DropInElement.PaymentMethodsConfiguration, completion: @escaping (Swift.Result<Elements.DropInElement, Swift.Error>) -> Swift.Void)
    @objc deinit
  }
  @objc deinit
}
final public class RedirectElement : Elements.ActionElement {
  public enum Error : Swift.Error {
    case appNotFound
    public static func == (a: Elements.RedirectElement.Error, b: Elements.RedirectElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  weak final public var delegate: Elements.ActionElementDelegate?
  weak final public var presentationDelegate: Elements.PresentationDelegate?
  public init(style: Elements.RedirectElementStyle? = nil)
  final public func handle(_ action: Elements.RedirectAction)
  @discardableResult
  public static func applicationDidOpen(from url: Foundation.URL) -> Swift.Bool
  @objc deinit
}
extension RedirectElement : Elements.ActionElementDelegate {
  final public func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  final public func didComplete(from element: Elements.ActionElement)
  final public func didFail(with error: Swift.Error, from element: Elements.ActionElement)
  final public func didOpenExternalApplication(_ element: Elements.ActionElement)
}
public enum BillingAddressFields : Swift.UInt {
  case none
  case postalCode
  case full
  case name
  public typealias RawValue = Swift.UInt
  public init?(rawValue: Swift.UInt)
  public var rawValue: Swift.UInt {
    get
  }
}
public class AddressParams : Swift.Codable {
  public var name: Swift.String?
  public var line1: Swift.String?
  public var line2: Swift.String?
  public var city: Swift.String?
  public var state: Swift.String?
  public var postalCode: Swift.String?
  public var country: Swift.String?
  public var phone: Swift.String?
  public var email: Swift.String?
  public init()
  public init(pkContact contact: PassKit.PKContact)
  public func pkContactValue() -> PassKit.PKContact
  public init(cnContact contact: Contacts.CNContact)
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CreatePaymentMethodResponse : Elements.Response {
  public let token: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class FontPlate {
  @objc deinit
}
public protocol FontSchema {
  var primaryTextFont: UIKit.UIFont { get }
  var boldPrimaryTextFont: UIKit.UIFont { get }
  var secondaryTextFont: UIKit.UIFont { get }
  var boldSecondaryTextFont: UIKit.UIFont { get }
  var smallTextFont: UIKit.UIFont { get }
  var largeTextFont: UIKit.UIFont { get }
  var boldLargeTextFont: UIKit.UIFont { get }
}
final public class LightThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
final public class DarkThemeFonts : Elements.FontSchema {
  public init()
  final public var primaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldPrimaryTextFont: UIKit.UIFont {
    get
  }
  final public var smallTextFont: UIKit.UIFont {
    get
  }
  final public var secondaryTextFont: UIKit.UIFont {
    get
  }
  final public var boldSecondaryTextFont: UIKit.UIFont {
    get
  }
  final public var largeTextFont: UIKit.UIFont {
    get
  }
  final public var boldLargeTextFont: UIKit.UIFont {
    get
  }
  @objc deinit
}
public protocol FormTextItemViewDelegate : AnyObject {
  func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
public protocol AnyFormTextItemView : Elements.AnyFormItemView {
  var delegate: Elements.FormTextItemViewDelegate? { get set }
}
@_inheritsConvenienceInitializers open class FormTextItemView<ItemType> : Elements.FormValueItemView<Swift.String, Elements.FormTextItemStyle, ItemType>, UIKit.UITextFieldDelegate, Elements.AnyFormTextItemView where ItemType : Elements.FormTextItem {
  required public init(item: ItemType)
  weak public var delegate: Elements.FormTextItemViewDelegate?
  public var textField: UIKit.UITextField {
    get
    set
  }
  public var accessory: Elements.FormTextItemView<ItemType>.AccessoryType {
    get
    set
  }
  override public func validate()
  override open func configureSeparatorView()
  @objc override dynamic open var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    @objc get
  }
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @objc public func textFieldShouldReturn(_: UIKit.UITextField) -> Swift.Bool
  @objc open func textFieldDidEndEditing(_: UIKit.UITextField)
  @objc open func textFieldDidBeginEditing(_: UIKit.UITextField)
  open func updateValidationStatus(forced: Swift.Bool = false)
  @objc deinit
}
extension FormTextItemView {
  public enum AccessoryType : Swift.Equatable {
    case invalid
    case valid
    case customView(UIKit.UIView)
    case none
    public static func == (a: Elements.FormTextItemView<ItemType>.AccessoryType, b: Elements.FormTextItemView<ItemType>.AccessoryType) -> Swift.Bool
  }
}
public struct StripeTokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.StripeVaultToken
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListSection {
  public var title: Swift.String?
  public var items: [Elements.ListItem]
  public init(title: Swift.String? = nil, items: [Elements.ListItem])
}
public protocol ViewControllerDelegate : AnyObject {
  func viewDidLoad(viewController: UIKit.UIViewController)
  func viewDidAppear(viewController: UIKit.UIViewController)
}
public struct ChargeData : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol Theme : Swift.Equatable {
  var identifier: Swift.String { get }
  static var variants: [Self] { get }
  static var manager: Elements.ThemeManager<Self> { get }
  var colors: Elements.ColorSchema { get set }
  var fonts: Elements.FontSchema { get set }
  var images: Elements.ImageAssets { get set }
}
extension Theme {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class FullFormAddressItem : Elements.FormValueItem<Elements.AddressInfo, Elements.AddressStyle>, Elements.Observer {
  override final public var subitems: [Elements.FormItem] {
    get
  }
  public init(initialCountry: Swift.String, style: Elements.AddressStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public enum ElementsLogging {
  public static var isEnabled: Swift.Bool
}
public func elementsPrint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
@_hasMissingDesignatedInitializers final public class AmountFormatter {
  public static func formatted(amount: Swift.Int, currencyCode: Swift.String) -> Swift.String?
  public static func minorUnitAmount(from majorUnitAmount: Swift.Double, currencyCode: Swift.String) -> Swift.Int
  public static func minorUnitAmount(from majorUnitAmount: Foundation.Decimal, currencyCode: Swift.String) -> Swift.Int
  @objc deinit
}
public class RegularExpressionValidator : Elements.LengthValidator {
  public init(regularExpression: Swift.String, minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  override public func maximumLength(for _: Swift.String) -> Swift.Int
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class NetworkImageView : UIKit.UIImageView {
  public var imageURL: Foundation.URL? {
    get
    set
  }
  @objc override dynamic open func didMoveToWindow()
  @objc deinit
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_hasMissingDesignatedInitializers final public class ContainerView : UIKit.UIView {
  public init(body: UIKit.UIView, padding: UIKit.UIEdgeInsets = .zero)
  final public func setupConstraints()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension CardElement {
  public enum AddressFormType {
    case full
    case postalCode
    case none
    public static func == (a: Elements.CardElement.AddressFormType, b: Elements.CardElement.AddressFormType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Configuration {
    public var showsHolderNameField: Swift.Bool
    public var showsStorePaymentMethodField: Swift.Bool
    public var showsSecurityCodeField: Swift.Bool
    public var billingAddressMode: Elements.CardElement.AddressFormType
    public var stored: Elements.StoredCardConfiguration
    public var allowedCardTypes: [Elements.CardType]?
    public init(showsHolderNameField: Swift.Bool = false, showsStorePaymentMethodField: Swift.Bool = true, showsSecurityCodeField: Swift.Bool = true, billingAddressMode: Elements.CardElement.AddressFormType = .none, storedCardConfiguration: Elements.StoredCardConfiguration = StoredCardConfiguration(), allowedCardTypes: [Elements.CardType]? = nil)
  }
}
extension AbstractPersonalInformationElement : Elements.LoadingElement, Elements.TrackableElement {
  public func stopLoading()
}
public enum PersonalInformation : Swift.Equatable {
  case firstName
  case lastName
  case email
  case phone
  case custom(Elements.FormItemInjector)
  public static func == (lhs: Elements.PersonalInformation, rhs: Elements.PersonalInformation) -> Swift.Bool
}
extension AbstractPersonalInformationElement {
  public struct Configuration {
    public let fields: [Elements.PersonalInformation]
    public init(fields: [Elements.PersonalInformation])
  }
}
public protocol ParameterlessInitializable {
  init()
}
extension ElementsScope where Base : UIKit.UIView {
  public func snapShot() -> UIKit.UIImage?
  public func hideWithAnimation(_ hidden: Swift.Bool)
}
public struct EmptyPaymentDetails : Elements.PaymentMethodDetails {
  public let type: Swift.String
  public init(type: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListPaymentMethodsResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
final public class FormButtonItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let style: Elements.FormButtonItemStyle
  final public var identifier: Swift.String?
  final public var title: Swift.String?
  @Elements.Observable @_projectedValueProperty($showsActivityIndicator) final public var showsActivityIndicator: Swift.Bool {
    get
    set
    _modify
  }
  final public var $showsActivityIndicator: Elements.Observable<Swift.Bool> {
    get
  }
  @Elements.Observable @_projectedValueProperty($enabled) final public var enabled: Swift.Bool {
    get
    set
    _modify
  }
  final public var $enabled: Elements.Observable<Swift.Bool> {
    get
  }
  final public var buttonSelectionHandler: (() -> Swift.Void)?
  public init(style: Elements.FormButtonItemStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public struct WalletsPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let supportedPaymentMethods: [Elements.PaymentMethod]
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, supportedPaymentMethods: [Elements.PaymentMethod])
}
public class ListItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  final public let style: Elements.ListItemStyle
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var imageURL: Foundation.URL?
  public var showsDisclosureIndicator: Swift.Bool
  public var selectionHandler: (() -> Swift.Void)?
  public var identifier: Swift.String?
  final public let canModifyIcon: Swift.Bool
  public init(title: Swift.String, imageURL: Foundation.URL? = nil, style: Elements.ListItemStyle = ListItemStyle(), showsDisclosureIndicator: Swift.Bool = true, selectionHandler: (() -> Swift.Void)? = nil, canModifyIcon: Swift.Bool = true)
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension ListItem : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Elements.ListItem, rhs: Elements.ListItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
open class FormItemView<ItemType> : UIKit.UIView, Elements.AnyFormItemView, Elements.Observer where ItemType : Elements.FormItem {
  final public let item: ItemType
  required public init(item: ItemType)
  @available(*, unavailable)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  open var childItemViews: [Elements.AnyFormItemView] {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol AnyFormItemView : UIKit.UIView {
  var parentItemView: Elements.AnyFormItemView? { get }
  var childItemViews: [Elements.AnyFormItemView] { get }
}
extension AnyFormItemView {
  public var parentItemView: Elements.AnyFormItemView? {
    get
  }
  public var flatSubitemViews: [Elements.AnyFormItemView] {
    get
  }
}
public struct LocalizationKey {
  public static let submitButton: Elements.LocalizationKey
  public static let submitButtonFormatted: Elements.LocalizationKey
  public static let cancelButton: Elements.LocalizationKey
  public static let dismissButton: Elements.LocalizationKey
  public static let errorTitle: Elements.LocalizationKey
  public static let errorUnknown: Elements.LocalizationKey
  public static let validationAlertTitle: Elements.LocalizationKey
  public static let paymentMethodsOtherMethods: Elements.LocalizationKey
  public static let paymentMethodsTitle: Elements.LocalizationKey
  public static let sepaIbanItemTitle: Elements.LocalizationKey
  public static let sepaIbanItemInvalid: Elements.LocalizationKey
  public static let sepaNameItemTitle: Elements.LocalizationKey
  public static let sepaNameItemPlaceholder: Elements.LocalizationKey
  public static let sepaConsentLabel: Elements.LocalizationKey
  public static let sepaNameItemInvalid: Elements.LocalizationKey
  public static let cardStoreDetailsButton: Elements.LocalizationKey
  public static let cardNameItemTitle: Elements.LocalizationKey
  public static let cardNameItemPlaceholder: Elements.LocalizationKey
  public static let cardNameItemInvalid: Elements.LocalizationKey
  public static let cardNumberItemTitle: Elements.LocalizationKey
  public static let cardNumberItemPlaceholder: Elements.LocalizationKey
  public static let cardNumberItemInvalid: Elements.LocalizationKey
  public static let cardExpiryItemTitle: Elements.LocalizationKey
  public static let cardExpiryItemPlaceholder: Elements.LocalizationKey
  public static let cardExpiryItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemInvalid: Elements.LocalizationKey
  public static let cardCvcItemTitle: Elements.LocalizationKey
  public static let cardCvcItemPlaceholder: Elements.LocalizationKey
  public static let cardStoredTitle: Elements.LocalizationKey
  public static let cardStoredMessage: Elements.LocalizationKey
  public static let cardStoredExpires: Elements.LocalizationKey
  public static let dropInStoredTitle: Elements.LocalizationKey
  public static let dropInPreselectedOpenAllTitle: Elements.LocalizationKey
  public static let continueTo: Elements.LocalizationKey
  public static let phoneNumberTitle: Elements.LocalizationKey
  public static let phoneNumberInvalid: Elements.LocalizationKey
  public static let phoneNumberPlaceholder: Elements.LocalizationKey
  public static let cardCvcItemPlaceholderDigits: Elements.LocalizationKey
  public static let emailItemTitle: Elements.LocalizationKey
  public static let emailItemPlaceHolder: Elements.LocalizationKey
  public static let emailItemInvalid: Elements.LocalizationKey
  public static let mbwayConfirmPayment: Elements.LocalizationKey
  public static let awaitWaitForConfirmation: Elements.LocalizationKey
  public static let blikConfirmPayment: Elements.LocalizationKey
  public static let blikInvalid: Elements.LocalizationKey
  public static let blikCode: Elements.LocalizationKey
  public static let blikHelp: Elements.LocalizationKey
  public static let blikPlaceholder: Elements.LocalizationKey
  public static let preauthorizeWith: Elements.LocalizationKey
  public static let confirmPreauthorization: Elements.LocalizationKey
  public static let cardCvcItemTitleOptional: Elements.LocalizationKey
  public static let confirmPurchase: Elements.LocalizationKey
  public static let lastName: Elements.LocalizationKey
  public static let firstName: Elements.LocalizationKey
  public static let cardPinTitle: Elements.LocalizationKey
  public static let missingField: Elements.LocalizationKey
  public static let cardApplyGiftcard: Elements.LocalizationKey
  public static let voucherCollectionInstitutionNumber: Elements.LocalizationKey
  public static let voucherMerchantName: Elements.LocalizationKey
  public static let voucherExpirationDate: Elements.LocalizationKey
  public static let voucherPaymentReferenceLabel: Elements.LocalizationKey
  public static let voucherShopperName: Elements.LocalizationKey
  public static let buttonCopy: Elements.LocalizationKey
  public static let voucherIntroduction: Elements.LocalizationKey
  public static let voucherReadInstructions: Elements.LocalizationKey
  public static let voucherSaveImage: Elements.LocalizationKey
  public static let voucherFinish: Elements.LocalizationKey
  public static let pixInstructions: Elements.LocalizationKey
  public static let pixCopyButton: Elements.LocalizationKey
  public static let pixExpirationLabel: Elements.LocalizationKey
  public static let billingAddressSectionTitle: Elements.LocalizationKey
  public static let deliveryAddressSectionTitle: Elements.LocalizationKey
  public static let countryFieldTitle: Elements.LocalizationKey
  public static let addressFieldTitle: Elements.LocalizationKey
  public static let addressFieldPlaceholder: Elements.LocalizationKey
  public static let streetFieldTitle: Elements.LocalizationKey
  public static let streetFieldPlaceholder: Elements.LocalizationKey
  public static let houseNumberFieldTitle: Elements.LocalizationKey
  public static let houseNumberFieldPlaceholder: Elements.LocalizationKey
  public static let cityFieldTitle: Elements.LocalizationKey
  public static let cityFieldPlaceholder: Elements.LocalizationKey
  public static let cityTownFieldTitle: Elements.LocalizationKey
  public static let cityTownFieldPlaceholder: Elements.LocalizationKey
  public static let postalCodeFieldTitle: Elements.LocalizationKey
  public static let postalCodeFieldPlaceholder: Elements.LocalizationKey
  public static let zipCodeFieldTitle: Elements.LocalizationKey
  public static let zipCodeFieldPlaceholder: Elements.LocalizationKey
  public static let stateFieldTitle: Elements.LocalizationKey
  public static let stateFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateFieldPlaceholder: Elements.LocalizationKey
  public static let stateOrProvinceFieldTitle: Elements.LocalizationKey
  public static let stateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let selectStateOrProvinceFieldPlaceholder: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldTitle: Elements.LocalizationKey
  public static let provinceOrTerritoryFieldPlaceholder: Elements.LocalizationKey
  public static let apartmentSuiteFieldTitle: Elements.LocalizationKey
  public static let apartmentSuiteFieldPlaceholder: Elements.LocalizationKey
  public static let errorFeedbackEmptyField: Elements.LocalizationKey
  public static let errorFeedbackIncorrectFormat: Elements.LocalizationKey
  public static let fieldTitleOptional: Elements.LocalizationKey
  public init(key: Swift.String)
}
final public class CardNumberValidator : Elements.Validator {
  public init()
  final public func isValid(_ value: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public struct ThreeDS2FingerprintAction : Swift.Decodable {
  public let fingerprintToken: Swift.String
  public let authorisationToken: Swift.String?
  public let paymentData: Swift.String?
  public init(fingerprintToken: Swift.String, authorisationToken: Swift.String? = nil, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
@objc(ELEFormViewController) open class FormViewController : UIKit.UIViewController, Elements.Localizable, Elements.KeyboardObserver, Elements.Observer, Elements.PreferredContentSizeConsumer {
  public var requiresKeyboardInput: Swift.Bool {
    get
  }
  final public let style: Elements.ViewStyle
  weak public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ViewStyle)
  @objc deinit
  @available(*, unavailable)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  public var keyboardObserver: Any?
  public func startObserving()
  public func willUpdatePreferredContentSize()
  public func didUpdatePreferredContentSize()
  public func append<T>(_ item: T) where T : Elements.FormItem
  public var localizationParameters: Elements.LocalizationParameters?
  public func validate() -> Swift.Bool
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @discardableResult
  @objc override dynamic public func resignFirstResponder() -> Swift.Bool
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension FormViewController : Elements.FormTextItemViewDelegate {
  public func didReachMaximumLength<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
  public func didSelectReturnKey<T>(in itemView: Elements.FormTextItemView<T>) where T : Elements.FormTextItem
}
public struct RedirectAction : Swift.Decodable {
  public let url: Foundation.URL
  public let paymentData: Swift.String?
  public init(url: Foundation.URL, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
@propertyWrapper final public class Observable<ValueType> : Elements.EventPublisher where ValueType : Swift.Equatable {
  public init(_ value: ValueType)
  final public var wrappedValue: ValueType {
    get
    set
  }
  public typealias Event = ValueType
  final public var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Elements.Observable<ValueType>.Event>]
  final public var projectedValue: Elements.Observable<ValueType> {
    get
  }
  @objc deinit
}
public struct ListStoredPaymentMethodsResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
public typealias URLHandler = (Foundation.URL) -> Swift.Void
public enum RedirectListener {
  public static func registerForURL(using handler: @escaping Elements.URLHandler)
}
extension DropInElement {
  final public class PaymentMethodsConfiguration {
    final public var card: Elements.DropInElement.CardConfiguration
    final public var applePay: Elements.DropInElement.ApplePayConfiguration?
    final public let environment: Elements.Environment
    final public var localizationParameters: Elements.LocalizationParameters?
    final public var payment: Elements.Payment?
    public init(environment: Elements.Environment)
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class CardConfiguration {
    final public var showsHolderNameField: Swift.Bool
    final public var showsStorePaymentMethodField: Swift.Bool
    final public var showsSecurityCodeField: Swift.Bool
    final public var billingAddress: Elements.CardElement.AddressFormType
    final public var stored: Elements.StoredCardConfiguration
    @objc deinit
  }
  final public class ApplePayConfiguration {
    final public var summaryItems: [PassKit.PKPaymentSummaryItem]
    final public var merchantIdentifier: Swift.String
    final public var merchantName: Swift.String
    final public var requiredBillingContactFields: Swift.Set<PassKit.PKContactField>
    final public var requiredShippingContactFields: Swift.Set<PassKit.PKContactField>
    final public var excludedCardNetworks: [PassKit.PKPaymentNetwork]
    public init(summaryItems: [PassKit.PKPaymentSummaryItem], merchantIdentifier: Swift.String, requiredBillingContactFields: Swift.Set<PassKit.PKContactField> = [], requiredShippingContactFields: Swift.Set<PassKit.PKContactField> = [])
    @objc deinit
  }
}
public struct PhoneExtension : Swift.Decodable, Swift.Equatable {
  public let value: Swift.String
  public let countryCode: Swift.String
  public var countryDisplayName: Swift.String {
    get
  }
  public init(value: Swift.String, countryCode: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.PhoneExtension, b: Elements.PhoneExtension) -> Swift.Bool
}
public enum PhoneNumberPaymentMethod {
  case qiwiWallet
  case mbWay
  case generic
  public static func == (a: Elements.PhoneNumberPaymentMethod, b: Elements.PhoneNumberPaymentMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct PhoneExtensionsQuery {
  public let codes: [Swift.String]
  public init(codes: [Swift.String])
  public init(paymentMethod: Elements.PhoneNumberPaymentMethod)
}
public enum PhoneExtensionsRepository {
  public static func get(with query: Elements.PhoneExtensionsQuery) -> [Elements.PhoneExtension]
}
public struct ElementsScope<Base> {
  public let base: Base
  public init(base: Base)
}
public protocol ElementsCompatible {
  associatedtype ElementsBase
  var elements: Elements.ElementsScope<Self.ElementsBase> { get }
}
extension ElementsCompatible {
  public var elements: Elements.ElementsScope<Self> {
    get
  }
}
public struct ListItemStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var subtitle: Elements.TextStyle
  public var image: Elements.ImageStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle, subtitle: Elements.TextStyle, image: Elements.ImageStyle)
  public init()
}
extension ListItemStyle : Swift.Equatable {
  public static func == (lhs: Elements.ListItemStyle, rhs: Elements.ListItemStyle) -> Swift.Bool
}
public protocol DropInElementDelegate : AnyObject {
  func didSubmit(_ data: Elements.PaymentElementData, for paymentMethod: Elements.PaymentMethod, from element: Elements.DropInElement)
  func didProvide(_ data: Elements.ActionElementData, from element: Elements.DropInElement)
  func didComplete(from element: Elements.DropInElement)
  func didFail(with error: Swift.Error, from element: Elements.DropInElement)
  func didCancel(element: Elements.PaymentElement, from dropInElement: Elements.DropInElement)
}
extension DropInElementDelegate {
  public func didCancel(element: Elements.PaymentElement, from dropInElement: Elements.DropInElement)
}
public protocol APIEnvironment {
  var baseURL: Foundation.URL { get }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
}
public struct PspToken : Swift.Codable {
  public let pspAccount: Elements.PspAccount
  public let customerId: Swift.String?
  public let token: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PspCustomer : Swift.Codable {
  public let pspAccount: Elements.PspAccount
  public let customerId: Swift.String
  public init(pspAccount: Elements.PspAccount, customerId: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum SupportedPspType : Swift.String {
  case stripe
  case adyen
  case braintree
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct PspAccount : Swift.Codable {
  public let pspType: Swift.String
  public let accountId: Swift.String?
  public init(pspType: Elements.SupportedPspType, accountId: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ElementsCardResponse : Swift.Codable {
  public let id: Swift.String
  public let last4: Swift.String?
  public let expiryMonth: Swift.UInt?
  public let expiryYear: Swift.UInt?
  public let brand: Swift.String?
  public let fingerprint: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum ElementsTokenizationStatus : Swift.String, Swift.Codable {
  case success
  case partiallySucceeded
  case unknown
  public init(from decoder: Swift.Decoder) throws
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct ElementsToken : Elements.Response {
  public let status: Elements.ElementsTokenizationStatus
  public let pspTokens: [Elements.PspToken]
  public let card: Elements.ElementsCardResponse?
  public init(from decoder: Swift.Decoder) throws
}
public protocol Validator {
  func isValid(_ value: Swift.String) -> Swift.Bool
  func maximumLength(for value: Swift.String) -> Swift.Int
}
public protocol CardElementDelegate : AnyObject {
  func didChangeBIN(_ value: Swift.String, element: Elements.CardElement)
  func didChangeCardBrand(_ value: [Elements.CardBrand]?, element: Elements.CardElement)
}
public class CardElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable, Elements.Observer, Elements.LoadingElement {
  final public let style: Elements.FormElementStyle
  public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak public var cardElementDelegate: Elements.CardElementDelegate?
  final public let supportedCardTypes: [Elements.CardType]
  final public let configuration: Elements.CardElement.Configuration
  weak public var delegate: Elements.PaymentElementDelegate? {
    get
    set
  }
  public var payment: Elements.Payment? {
    get
    set
  }
  public var environment: Elements.Environment {
    get
    set
  }
  public init(paymentMethod: Elements.AnyCardPaymentMethod, configuration: Elements.CardElement.Configuration = Configuration(), style: Elements.FormElementStyle = FormElementStyle())
  public var viewController: UIKit.UIViewController {
    get
  }
  public var requiresModalPresentation: Swift.Bool {
    get
  }
  public var localizationParameters: Elements.LocalizationParameters?
  public func stopLoading()
  @objc deinit
}
public struct CardDetails : Elements.PaymentMethodDetails, Elements.BillingAddressInformation {
  public let type: Swift.String
  public let storedPaymentMethodIdentifier: Swift.String?
  public let card: Elements.ElementsCardParams?
  public let fundingSource: Elements.CardFundingSource?
  public var billingAddress: Elements.AddressInfo?
  public init(paymentMethod: Elements.AnyCardPaymentMethod, card: Elements.ElementsCardParams, holderName: Swift.String? = nil, billingAddress: Elements.AddressInfo? = nil)
  public init(paymentMethod: Elements.StoredCardPaymentMethod, securityCode: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PaymentMethods : Swift.Decodable {
  public let regular: [Elements.PaymentMethod]
  public let stored: [Elements.StoredPaymentMethod]
  public init(regular: [Elements.PaymentMethod], stored: [Elements.StoredPaymentMethod])
  public func paymentMethod<T>(ofType type: T.Type) -> T? where T : Elements.PaymentMethod
  public init(from decoder: Swift.Decoder) throws
}
public enum AnyPaymentMethod : Swift.Decodable {
  case storedCard(Elements.StoredCardPaymentMethod)
  case storedPayPal(Elements.StoredPayPalPaymentMethod)
  case storedRedirect(Elements.StoredRedirectPaymentMethod)
  case card(Elements.AnyCardPaymentMethod)
  case issuerList(Elements.IssuerListPaymentMethod)
  case redirect(Elements.RedirectPaymentMethod)
  case applePay(Elements.ApplePayPaymentMethod)
  case wallets(Elements.WalletsPaymentMethod)
  case none
  public var value: Elements.PaymentMethod? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum AnyStoredPaymentMethod : Swift.Decodable {
  case storedCard(Elements.StoredCardPaymentMethod)
  case storedPayPal(Elements.StoredPayPalPaymentMethod)
  case storedRedirect(Elements.StoredRedirectPaymentMethod)
  case none
  public var value: Elements.PaymentMethod? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
final public class FormSeparatorItem : Elements.FormItem {
  final public var subitems: [Elements.FormItem]
  final public let color: UIKit.UIColor
  final public var identifier: Swift.String?
  public init(color: UIKit.UIColor)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol ActionElement : Elements.Element {
  var delegate: Elements.ActionElementDelegate? { get set }
}
public protocol ActionElementDelegate : AnyObject {
  func didOpenExternalApplication(_ element: Elements.ActionElement)
  func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  func didComplete(from element: Elements.ActionElement)
  func didFail(with error: Swift.Error, from element: Elements.ActionElement)
}
extension ActionElementDelegate {
  public func didOpenExternalApplication(_: Elements.ActionElement)
}
public protocol PresentationDelegate : AnyObject {
  func present(element: Elements.PresentableElement)
}
@_inheritsConvenienceInitializers final public class CardSecurityCodeFormatter : Elements.NumericFormatter, Elements.Observer {
  override public init()
  public init(publisher: Elements.Observable<Elements.CardType?>)
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol APIClientProtocol {
  typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  func perform<R>(_ request: R, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class APIClient : Elements.APIClientProtocol {
  final public let environment: Elements.APIEnvironment
  public init(environment: Elements.APIEnvironment)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.APIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@_inheritsConvenienceInitializers open class NumericStringValidator : Elements.LengthValidator {
  override public func isValid(_ value: Swift.String) -> Swift.Bool
  @objc deinit
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
}
extension UIActivityIndicatorView.Style {
}
@_inheritsConvenienceInitializers final public class FormTextInputItem : Elements.FormTextItem {
  override public init(style: Elements.FormTextItemStyle = .init())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public protocol AnyCardPaymentMethod : Elements.PaymentMethod {
  var cardData: [Elements.SupportedCardData] { get }
  var fundingSource: Elements.CardFundingSource? { get }
}
public enum CardFundingSource : Swift.String, Swift.Codable {
  case debit
  case credit
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct AwaitElementStyle : Elements.ViewStyle {
  public var image: Elements.ImageStyle
  public var message: Elements.TextStyle
  public var spinnerTitle: Elements.TextStyle
  public var backgroundColor: UIKit.UIColor
  public init()
}
public protocol AnyAppLauncher {
  func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
public struct AppLauncher : Elements.AnyAppLauncher {
  public init()
  public func openCustomSchemeUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
  public func openUniversalAppUrl(_ url: Foundation.URL, completion: ((Swift.Bool) -> Swift.Void)?)
}
public typealias Completion<T> = (T) -> Swift.Void
public enum ThreeDS2Action : Swift.Decodable {
  case fingerprint(Elements.ThreeDS2FingerprintAction)
  case challenge(Elements.ThreeDS2ChallengeAction)
  public init(from decoder: Swift.Decoder) throws
  public enum ActionType : Swift.String, Swift.Decodable {
    case fingerprint
    case challenge
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
extension UIButton {
  convenience public init(style: Elements.ButtonStyle)
}
extension CardElement {
  public enum Error : Swift.Error {
    case missingClientKey
    public static func == (a: Elements.CardElement.Error, b: Elements.CardElement.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension CardElement : Elements.TrackableElement {
  public func viewDidLoad(viewController: UIKit.UIViewController)
}
public func localizedString(_ key: Elements.LocalizationKey, _ parameters: Elements.LocalizationParameters?, _ arguments: Swift.CVarArg...) -> Swift.String
public enum PaymentStyle {
  case needsRedirectToThirdParty(Swift.String)
  case immediate
}
public func localizedSubmitButtonTitle(with amount: Elements.Payment.Amount?, style: Elements.PaymentStyle, _ parameters: Elements.LocalizationParameters?) -> Swift.String
@objc final public class ListViewController : UIKit.UITableViewController {
  final public let style: Elements.ListElementStyle
  weak final public var delegate: Elements.ViewControllerDelegate?
  public init(style: Elements.ListElementStyle = ListElementStyle())
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  final public var sections: [Elements.ListSection] {
    get
    set
  }
  final public func startLoading(for item: Elements.ListItem)
  final public func stopLoading()
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @objc override final public func numberOfSections(in _: UIKit.UITableView) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override final public func tableView(_: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override final public func tableView(_: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc override final public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override final public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public enum ShopperInteraction : Swift.String, Swift.Decodable {
  case shopperPresent
  case shopperNotPresent
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct FormButtonItemStyle : Elements.ViewStyle {
  public var button: Elements.ButtonStyle
  public var backgroundColor: UIKit.UIColor
  public init(button: Elements.ButtonStyle)
  public init(button: Elements.ButtonStyle, background: UIKit.UIColor)
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
  public static func main(font: UIKit.UIFont, textColor: UIKit.UIColor, mainColor: UIKit.UIColor, cornerRounding: Elements.CornerRounding) -> Elements.FormButtonItemStyle
  public static func secondary(font: UIKit.UIFont, textColor: UIKit.UIColor) -> Elements.FormButtonItemStyle
}
public class FormLabelItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(text: Swift.String, style: Elements.TextStyle, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var style: Elements.TextStyle
  public var text: Swift.String
  public func build(with _: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public class FormContainerItem : Elements.FormItem {
  public var subitems: [Elements.FormItem]
  public init(content: Elements.FormItem, padding: UIKit.UIEdgeInsets = .zero, identifier: Swift.String? = nil)
  public var identifier: Swift.String?
  public var content: Elements.FormItem {
    get
  }
  public var padding: UIKit.UIEdgeInsets
  public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
extension FormItem {
  public func withPadding(padding: UIKit.UIEdgeInsets) -> Elements.FormContainerItem
}
public struct ImageStyle : Elements.TintableStyle {
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var cornerRounding: Elements.CornerRounding
  public var clipsToBounds: Swift.Bool
  public var contentMode: UIKit.UIView.ContentMode
  public var backgroundColor: UIKit.UIColor
  public var tintColor: UIKit.UIColor?
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRadius: CoreGraphics.CGFloat, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
  public init(borderColor: UIKit.UIColor?, borderWidth: CoreGraphics.CGFloat, cornerRounding: Elements.CornerRounding, clipsToBounds: Swift.Bool, contentMode: UIKit.UIView.ContentMode)
}
extension ImageStyle : Swift.Equatable {
  public static func == (lhs: Elements.ImageStyle, rhs: Elements.ImageStyle) -> Swift.Bool
}
public protocol Observer : AnyObject {
}
extension Observer {
  @discardableResult
  public func observe<T>(_ eventPublisher: T, eventHandler: @escaping Elements.EventHandler<T.Event>) -> Elements.Observation where T : Elements.EventPublisher
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Value?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>, with transformation: @escaping ((Value) -> Result)) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  @discardableResult
  public func bind<Value, Result, Target>(_ observable: Elements.Observable<Value>, at originKeyPath: Swift.KeyPath<Value, Result>, to target: Target, at keyPath: Swift.ReferenceWritableKeyPath<Target, Result?>) -> Elements.Observation where Value : Swift.Equatable, Target : AnyObject
  public func remove(_ observation: Elements.Observation)
}
public struct PhoneExtensionViewModel : Swift.CustomStringConvertible, Swift.Equatable {
  public let title: Swift.String
  public let phoneExtension: Swift.String
  public var description: Swift.String {
    get
  }
  public static func == (a: Elements.PhoneExtensionViewModel, b: Elements.PhoneExtensionViewModel) -> Swift.Bool
}
public typealias PhoneExtensionPickerItem = Elements.BasePickerElement<Elements.PhoneExtensionViewModel>
@_hasMissingDesignatedInitializers final public class FormPhoneExtensionPickerItem : Elements.BaseFormPickerItem<Elements.PhoneExtensionViewModel> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public typealias RegionPickerItem = Elements.BasePickerElement<Elements.Region>
@_hasMissingDesignatedInitializers final public class FormRegionPickerItem : Elements.BaseFormPickerItem<Elements.Region> {
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
public struct RedirectDetails : Elements.AdditionalDetails {
  public let returnURL: Foundation.URL
  public init(returnURL: Foundation.URL)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ListElementStyle : Elements.ViewStyle {
  public var listItem: Elements.ListItemStyle
  public var sectionHeader: Elements.ListSectionHeaderStyle
  public var backgroundColor: UIKit.UIColor
  public init(listItem: Elements.ListItemStyle, sectionHeader: Elements.ListSectionHeaderStyle)
  public init()
}
extension Bundle : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.Bundle
}
extension ElementsScope where Base : Foundation.Bundle {
  public func isSchemeConfigured(_ scheme: Swift.String) -> Swift.Bool
}
public struct Region : Swift.Decodable, Swift.CustomStringConvertible, Swift.Equatable {
  public let identifier: Swift.String
  public let name: Swift.String
  public var description: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: Elements.Region, b: Elements.Region) -> Swift.Bool
}
public class RegionRepository {
  public init(environment: Elements.Environment)
  public func getCountries(locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  public func getSubRegions(for countryCode: Swift.String, locale: Swift.String, callback: @escaping (([Elements.Region]) -> Swift.Void))
  @objc deinit
}
public struct ApplePayDetails : Elements.PaymentMethodDetails {
  public let type: Swift.String
  public let token: Swift.String
  public let network: Swift.String
  public let billingContact: PassKit.PKContact?
  public let shippingContact: PassKit.PKContact?
  public let transactionIdentifier: Swift.String?
  public let instrumentName: Swift.String?
  public init(paymentMethod: Elements.ApplePayPaymentMethod, token: Swift.String, network: Swift.String, billingContact: PassKit.PKContact?, shippingContact: PassKit.PKContact?, transactionIdentifier: Swift.String?, instrumentName: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
}
public enum AppImageName : Swift.String {
  case applePayIcon
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum ImageResources {
}
public protocol ImageAssets {
}
final public class LightThemeAssets : Elements.ImageAssets {
  public init()
  @objc deinit
}
final public class DarkThemeAssets : Elements.ImageAssets {
  public init()
  @objc deinit
}
infix operator |> : AdditionPrecedence
public enum HTTPMethod : Swift.String {
  case post
  case get
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public protocol Request : Swift.Encodable {
  associatedtype ResponseType : Elements.Response
  var path: Swift.String { get }
  var counter: Swift.UInt { get set }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
  var method: Elements.HTTPMethod { get }
}
public protocol Response : Swift.Decodable {
}
public protocol PaymentElementBuilder {
  func build(paymentMethod: Elements.StoredCardPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.StoredPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.CardPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.ApplePayPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.WalletsPaymentMethod) -> Elements.PaymentElement?
  func build(paymentMethod: Elements.PaymentMethod) -> Elements.PaymentElement?
}
final public class StoredPaymentMethodElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable {
  final public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak final public var delegate: Elements.PaymentElementDelegate?
  public init(paymentMethod: Elements.StoredPaymentMethod)
  final public var viewController: UIKit.UIViewController {
    get
    set
  }
  final public var localizationParameters: Elements.LocalizationParameters?
  @objc deinit
}
public struct StoredPaymentDetails : Elements.PaymentMethodDetails {
  public init(paymentMethod: Elements.StoredPaymentMethod)
  public func encode(to encoder: Swift.Encoder) throws
}
final public class CardSecurityCodeValidator : Elements.NumericStringValidator, Elements.Observer {
  public init()
  public init(publisher: Elements.Observable<Elements.CardType?>)
  override public init(minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
public struct LocalizationParameters : Swift.Equatable {
  public let locale: Swift.String?
  public let tableName: Swift.String?
  public let keySeparator: Swift.String?
  public let bundle: Foundation.Bundle?
  public init(bundle: Foundation.Bundle? = nil, tableName: Swift.String? = nil, keySeparator: Swift.String? = nil, locale: Swift.String? = nil)
  public static func == (a: Elements.LocalizationParameters, b: Elements.LocalizationParameters) -> Swift.Bool
}
public struct ApplePayPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let brands: [Swift.String]?
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, brands: [Swift.String]?)
  public init(from decoder: Swift.Decoder) throws
}
public struct AddressInfo : Swift.Equatable, Swift.Encodable {
  public init(city: Swift.String? = nil, country: Swift.String? = nil, houseNumberOrName: Swift.String? = nil, postalCode: Swift.String? = nil, stateOrProvince: Swift.String? = nil, street: Swift.String? = nil, apartment: Swift.String? = nil)
  public var city: Swift.String?
  public var country: Swift.String?
  public var houseNumberOrName: Swift.String?
  public var postalCode: Swift.String?
  public var stateOrProvince: Swift.String?
  public var street: Swift.String?
  public var apartment: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: Elements.AddressInfo, b: Elements.AddressInfo) -> Swift.Bool
}
public struct ListSectionHeaderStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
@_inheritsConvenienceInitializers final public class FormSwitchItemView : Elements.FormValueItemView<Swift.Bool, Elements.FormSwitchItemStyle, Elements.FormSwitchItem> {
  required public init(item: Elements.FormSwitchItem)
  @objc override final public func accessibilityActivate() -> Swift.Bool
  @objc deinit
}
public protocol KeyboardObserver : AnyObject {
  func startObserving()
  func stopObserving()
  var keyboardObserver: Any? { get set }
}
extension KeyboardObserver {
  public func startObserving(_ observer: @escaping (CoreGraphics.CGRect) -> Swift.Void)
  public func stopObserving()
}
final public class PhoneNumberValidator : Elements.RegularExpressionValidator {
  public init()
  override public init(regularExpression: Swift.String, minimumLength: Swift.Int? = super, maximumLength: Swift.Int? = super)
  @objc deinit
}
public struct ButtonStyle : Elements.ViewStyle {
  public var title: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var borderColor: UIKit.UIColor?
  public var borderWidth: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding)
  public init(title: Elements.TextStyle, cornerRadius: CoreGraphics.CGFloat, background: UIKit.UIColor)
  public init(title: Elements.TextStyle, cornerRounding: Elements.CornerRounding, background: UIKit.UIColor)
}
public class ElementsCardParams : Swift.Codable {
  final public let cardNumber: Swift.String
  final public let expiryMonth: Swift.UInt?
  final public let expiryYear: Swift.UInt?
  final public let securityCode: Swift.String?
  final public let holderName: Swift.String?
  public var address: Elements.AddressParams?
  public init(cardNumber: Swift.String, expiryMonth: Swift.UInt?, expiryYear: Swift.UInt?, securityCode: Swift.String?, holderName: Swift.String?)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias AssertionListner = (Swift.String) -> Swift.Void
public enum ElementsAssertion {
  public static func assert(message: Swift.String)
}
public struct Observation : Swift.Hashable {
  public static func == (lhs: Elements.Observation, rhs: Elements.Observation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class DropInElement : ObjectiveC.NSObject, Elements.PresentableElement {
  final public let paymentMethods: Elements.PaymentMethods
  weak final public var delegate: Elements.DropInElementDelegate?
  final public let style: Elements.DropInElement.Style
  final public let title: Swift.String
  public init(paymentMethods: Elements.PaymentMethods, paymentMethodsConfiguration: Elements.DropInElement.PaymentMethodsConfiguration, style: Elements.DropInElement.Style = Style(), title: Swift.String? = nil)
  final public var viewController: UIKit.UIViewController {
    get
  }
  final public func handle(_ action: Elements.Action)
  @objc override dynamic public init()
  @objc deinit
}
extension DropInElement : Elements.PaymentElementDelegate {
  final public func didSubmit(_ data: Elements.PaymentElementData, from element: Elements.PaymentElement)
  final public func didFail(with error: Swift.Error, from element: Elements.PaymentElement)
}
extension DropInElement : Elements.ActionElementDelegate {
  final public func didOpenExternalApplication(_ element: Elements.ActionElement)
  final public func didComplete(from element: Elements.ActionElement)
  final public func didFail(with error: Swift.Error, from element: Elements.ActionElement)
  final public func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
}
extension DropInElement : Elements.PresentationDelegate {
  final public func present(element: Elements.PresentableElement)
}
extension DropInElement : Elements.FinalizableElement {
  final public func didFinalize(with success: Swift.Bool)
}
public protocol Formatter {
  func formattedValue(for value: Swift.String) -> Swift.String
  func sanitizedValue(for value: Swift.String) -> Swift.String
}
public struct TextStyle : Elements.ViewStyle {
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var textAlignment: UIKit.NSTextAlignment
  public var backgroundColor: UIKit.UIColor
  public var cornerRounding: Elements.CornerRounding
  public init(font: UIKit.UIFont, color: UIKit.UIColor, textAlignment: UIKit.NSTextAlignment)
  public init(font: UIKit.UIFont, color: UIKit.UIColor)
}
extension TextStyle : Swift.Equatable {
  public static func == (lhs: Elements.TextStyle, rhs: Elements.TextStyle) -> Swift.Bool
}
public protocol ColorSchema {
  var themeColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
  var lightBackgroundColor: UIKit.UIColor { get }
  var shadowColor: UIKit.UIColor { get }
  var primaryTextColorDarkCanvas: UIKit.UIColor { get }
  var secondaryTextColorDarkCanvas: UIKit.UIColor { get }
  var primaryTextColorLightCanvas: UIKit.UIColor { get }
  var secondaryTextColorLightCanvas: UIKit.UIColor { get }
  var errorColor: UIKit.UIColor { get }
  var separatorColor: UIKit.UIColor { get }
}
final public class LightThemeColors : Elements.ColorSchema {
  public init()
  final public var themeColor: UIKit.UIColor {
    get
  }
  final public var backgroundColor: UIKit.UIColor {
    get
  }
  final public var lightBackgroundColor: UIKit.UIColor {
    get
  }
  final public var shadowColor: UIKit.UIColor {
    get
  }
  final public var primaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorDarkCanvas: UIKit.UIColor {
    get
  }
  final public var primaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var secondaryTextColorLightCanvas: UIKit.UIColor {
    get
  }
  final public var separatorColor: UIKit.UIColor {
    get
  }
  final public var errorColor: UIKit.UIColor {
    get
  }
  @objc deinit
}
public enum Action : Swift.Decodable {
  case redirect(Elements.RedirectAction)
  public init(from decoder: Swift.Decoder) throws
}
public struct FormItemViewBuilder {
  public func build(with item: Elements.FormSwitchItem) -> Elements.FormItemView<Elements.FormSwitchItem>
  public func build(with item: Elements.FormSplitItem) -> Elements.FormItemView<Elements.FormSplitItem>
  public func build(with item: Elements.FormPhoneNumberItem) -> Elements.FormItemView<Elements.FormPhoneNumberItem>
  public func build(with item: Elements.FormPhoneExtensionPickerItem) -> Elements.BaseFormPickerItemView<Elements.PhoneExtensionViewModel>
  public func build(with item: Elements.FormRegionPickerItem) -> Elements.BaseFormPickerItemView<Elements.Region>
  public func build(with item: Elements.FormTextInputItem) -> Elements.FormItemView<Elements.FormTextInputItem>
  public func build(with item: Elements.ListItem) -> Elements.ListItemView
  public func build(with item: Elements.FormButtonItem) -> Elements.FormItemView<Elements.FormButtonItem>
  public func build(with item: Elements.FormSeparatorItem) -> Elements.FormItemView<Elements.FormSeparatorItem>
  public func build(with item: Elements.FormErrorItem) -> Elements.FormItemView<Elements.FormErrorItem>
  public func build(with item: Elements.FullFormAddressItem) -> Elements.FormItemView<Elements.FullFormAddressItem>
  public static func build(_ item: Elements.FormItem) -> Elements.AnyFormItemView
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc deinit
  @objc override dynamic public init()
}
extension SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct ContactDetail : Swift.Codable {
  public let emailAdress: Swift.String?
  public let phoneNumber: Swift.String?
  public let postalAddress: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
final public class LogoURLProvider {
  public init(environment: Elements.Environment)
  final public func logoURL(for paymentMethod: Elements.PaymentMethod, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  final public func logoURL(for issuer: Elements.IssuerListPaymentMethod.Issuer, paymentMethod: Elements.IssuerListPaymentMethod) -> Foundation.URL
  final public func logoURL(withName name: Swift.String, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  public static func logoURL(for paymentMethod: Elements.PaymentMethod, environment: Elements.Environment, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  public static func logoURL(for issuer: Elements.IssuerListPaymentMethod.Issuer, paymentMethod: Elements.IssuerListPaymentMethod, environment: Elements.Environment) -> Foundation.URL
  public static func logoURL(withName name: Swift.String, environment: Elements.Environment, size: Elements.LogoURLProvider.Size = .small) -> Foundation.URL
  @objc deinit
}
extension LogoURLProvider {
  public enum Size : Swift.String {
    case small
    case medium
    case large
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
public protocol PaymentMethodAware {
  var paymentMethod: Elements.PaymentMethod { get }
}
public protocol PaymentElement : Elements.PaymentAwareElement, Elements.PaymentMethodAware {
  var delegate: Elements.PaymentElementDelegate? { get set }
}
extension PaymentElement {
  public func submit(data: Elements.PaymentElementData, element: Elements.PaymentElement? = nil)
}
public protocol PaymentElementDelegate : AnyObject {
  func didSubmit(_ data: Elements.PaymentElementData, from element: Elements.PaymentElement)
  func didFail(with error: Swift.Error, from element: Elements.PaymentElement)
}
public protocol PaymentAwareElement : Elements.Element {
  var payment: Elements.Payment? { get set }
}
extension PaymentAwareElement {
  public var payment: Elements.Payment? {
    get
    set
  }
}
extension URLSession : Elements.ElementsCompatible {
  public typealias ElementsBase = Foundation.URLSession
}
extension ElementsScope where Base : Foundation.URLSession {
  public func dataTask(with url: Foundation.URL, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
  public func dataTask(with urlRequest: Foundation.URLRequest, completion: @escaping ((Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)) -> Foundation.URLSessionDataTask
}
public struct ChargeAPIResponse : Elements.Response {
  public init(from decoder: Swift.Decoder) throws
}
extension ElementsScope where Base : UIKit.UIViewController {
  public var topPresenter: UIKit.UIViewController {
    get
  }
  public func present(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
}
extension UIResponder : Elements.ElementsCompatible {
  public typealias ElementsBase = UIKit.UIResponder
}
public protocol PreferredContentSizeConsumer {
  func didUpdatePreferredContentSize()
  func willUpdatePreferredContentSize()
}
public struct FormTextItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var text: Elements.TextStyle
  public var placeholderText: Elements.TextStyle?
  public var icon: Elements.ImageStyle
  public var tintColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public init(title: Elements.TextStyle, text: Elements.TextStyle, placeholderText: Elements.TextStyle? = nil, icon: Elements.ImageStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
final public class PresentableElementWrapper : Elements.PresentableElement, Elements.Cancellable, Elements.FinalizableElement, Elements.LoadingElement {
  final public let viewController: UIKit.UIViewController
  final public let element: Elements.Element
  final public var requiresModalPresentation: Swift.Bool
  public init(element: Elements.Element, viewController: UIKit.UIViewController)
  final public func didCancel()
  final public func didFinalize(with success: Swift.Bool)
  final public func stopLoading()
  @objc deinit
}
public struct TokenizationRequest : Elements.Request {
  public typealias ResponseType = Elements.ElementsToken
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
}
public enum ViewIdentifierBuilder {
  public static func build(scopeInstance: Any, postfix: Swift.String) -> Swift.String
}
public struct AnyEncodable : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
open class NumericFormatter : Elements.Formatter {
  public init()
  open func formattedValue(for value: Swift.String) -> Swift.String
  open func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol FormValueItemStyle : Elements.TintableStyle {
  var separatorColor: UIKit.UIColor? { get }
  var title: Elements.TextStyle { get }
}
@_hasMissingDesignatedInitializers open class FormValueItem<ValueType, StyleType> : Elements.FormItem where ValueType : Swift.Equatable, StyleType : Elements.FormValueItemStyle {
  public var subitems: [Elements.FormItem] {
    get
  }
  public var identifier: Swift.String?
  public var value: ValueType {
    get
    set
  }
  public var publisher: Elements.Observable<ValueType>
  public var style: StyleType
  @Elements.Observable @_projectedValueProperty($title) public var title: Swift.String? {
    get
    set
    _modify
  }
  public var $title: Elements.Observable<Swift.String?> {
    get
  }
  open func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FormSwitchItem : Elements.FormValueItem<Swift.Bool, Elements.FormSwitchItemStyle> {
  public init(style: Elements.FormSwitchItemStyle = FormSwitchItemStyle())
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@objc final public class SubmitButton : UIKit.UIControl {
  public init(style: Elements.ButtonStyle)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var title: Swift.String? {
    get
    set
  }
  @objc override final public var accessibilityIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  final public var showsActivityIndicator: Swift.Bool {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct StoredCardConfiguration {
  public var showsSecurityCodeField: Swift.Bool
  public init()
}
@objc public class StripeCardParam : ObjectiveC.NSObject, Elements.StripeFormEncodable {
  @objc public var number: Swift.String
  @objc public var expMonth: Swift.UInt
  @objc public var expYear: Swift.UInt
  @objc public var cvc: Swift.String?
  @objc public var name: Swift.String?
  @objc public var currency: Swift.String?
  @objc public var additionalAPIParameters: [Swift.AnyHashable : Any]
  @objc public var addressLine1: Swift.String? {
    @objc get
    @objc set(addressLine1)
  }
  @objc public var addressLine2: Swift.String? {
    @objc get
    @objc set(addressLine2)
  }
  @objc public var addressCity: Swift.String? {
    @objc get
    @objc set(addressCity)
  }
  @objc public var addressState: Swift.String? {
    @objc get
    @objc set(addressState)
  }
  @objc public var addressZip: Swift.String? {
    @objc get
    @objc set(addressZip)
  }
  @objc public var addressCountry: Swift.String? {
    @objc get
    @objc set(addressCountry)
  }
  public init(number: Swift.String, expMonth: Swift.UInt = 0, expYear: Swift.UInt = 0, cvc: Swift.String?, name: Swift.String?, currency: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
  @objc public class func rootObjectName() -> Swift.String?
  @objc public class func propertyNamesToFormFieldNamesMapping() -> [Swift.String : Swift.String]
  @objc deinit
  @objc override dynamic public init()
}
public protocol ElementsViewControllerPresentingDelegate : AnyObject {
  func requestToShow(viewController: UIKit.UIViewController)
  func requestToDismiss()
}
public protocol ElementsActionCompletionDelegate : AnyObject {
  func didFail(with error: Swift.Error, driver: Elements.ElementsActionDriver)
  func didSuccess(with token: Swift.String?, driver: Elements.ElementsActionDriver)
}
final public class ElementsActionDriver : Elements.Element {
  final public class Configuration {
    final public let environment: Elements.Environment
    final public let returnURLScheme: Swift.String
    final public let style: Elements.RedirectElementStyle?
    public init(environment: Elements.Environment, returnURLScheme: Swift.String, style: Elements.RedirectElementStyle? = nil)
    @objc deinit
  }
  weak final public var presentingDelegate: Elements.ElementsViewControllerPresentingDelegate?
  weak final public var completionDelegate: Elements.ElementsActionCompletionDelegate?
  public init(configuration: Elements.ElementsActionDriver.Configuration, completionDelegate: Elements.ElementsActionCompletionDelegate? = nil, presentingDelegate: Elements.ElementsViewControllerPresentingDelegate? = nil)
  final public func requestPaypalSetup()
  final public func requestKakaoPaySetup()
  @objc deinit
}
extension ElementsActionDriver : Elements.ActionElementDelegate {
  final public func didProvide(_ data: Elements.ActionElementData, from element: Elements.ActionElement)
  final public func didComplete(from element: Elements.ActionElement)
  final public func didFail(with error: Swift.Error, from element: Elements.ActionElement)
}
extension ElementsActionDriver : Elements.PresentationDelegate {
  final public func present(element: Elements.PresentableElement)
}
@objc @_hasMissingDesignatedInitializers final public class ELEViewController : UIKit.UIViewController {
  public init(view: UIKit.UIView, title: Swift.String? = nil)
  @objc override final public func loadView()
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol Hidable {
  var isHidden: Elements.Observable<Swift.Bool> { get }
}
public protocol FormItem : AnyObject {
  var identifier: Swift.String? { get set }
  var subitems: [Elements.FormItem] { get }
  func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
}
extension FormItem {
  public var flatSubitems: [Elements.FormItem] {
    get
  }
}
public protocol ValidatableFormItem : Elements.FormItem {
  var validationFailureMessage: Swift.String? { get set }
  func isValid() -> Swift.Bool
}
public protocol InputViewRequiringFormItem : Elements.FormItem {
}
public struct FormElementStyle : Elements.TintableStyle {
  public var backgroundColor: UIKit.UIColor
  public var sectionHeader: Elements.TextStyle
  public var textField: Elements.FormTextItemStyle
  public var `switch`: Elements.FormSwitchItemStyle
  public var hintLabel: Elements.TextStyle
  public var mainButtonItem: Elements.FormButtonItemStyle
  public var secondaryButtonItem: Elements.FormButtonItemStyle
  public var separatorColor: UIKit.UIColor? {
    get
    set
  }
  public var addressStyle: Elements.AddressStyle {
    get
  }
  public var tintColor: UIKit.UIColor? {
    get
    set
  }
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.FormButtonItemStyle, secondaryButton: Elements.FormButtonItemStyle, helper: Elements.TextStyle, sectionHeader: Elements.TextStyle)
  public init(textField: Elements.FormTextItemStyle, switch: Elements.FormSwitchItemStyle, mainButton: Elements.ButtonStyle, secondaryButton: Elements.ButtonStyle)
  public init(tintColor: UIKit.UIColor)
  public init()
}
public struct SimpleScheduler : Elements.Scheduler {
  public init(maximumCount: Swift.Int)
  public func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public struct FormErrorItemStyle : Elements.ViewStyle {
  public var message: Elements.TextStyle
  public var cornerRounding: Elements.CornerRounding
  public var backgroundColor: UIKit.UIColor
  public init(message: Elements.TextStyle)
  public init()
}
final public class IBANValidator : Elements.Validator {
  public init()
  final public func isValid(_ value: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public enum AwaitPaymentMethod : Swift.String, Swift.Decodable {
  case mbway
  case blik
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public struct AwaitAction : Swift.Decodable {
  public let paymentMethodType: Elements.AwaitPaymentMethod
  public let paymentData: Swift.String
  public init(paymentData: Swift.String, paymentMethodType: Elements.AwaitPaymentMethod)
  public init(from decoder: Swift.Decoder) throws
}
@objc final public class ListItemView : UIKit.UIView, Elements.AnyFormItemView {
  final public var childItemViews: [Elements.AnyFormItemView]
  @objc dynamic public init()
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@_inheritsConvenienceInitializers open class FormValueItemView<ValueType, Style, ItemType> : Elements.FormItemView<ItemType>, Elements.AnyFormValueItemView where ValueType : Swift.Equatable, Style : Elements.FormValueItemStyle, ItemType : Elements.FormValueItem<ValueType, Style> {
  public var titleLabel: UIKit.UILabel {
    get
    set
  }
  required public init(item: ItemType)
  @objc override dynamic open func didAddSubview(_ subview: UIKit.UIView)
  open var isEditing: Swift.Bool {
    get
    set
  }
  open func validate()
  public var showsSeparator: Swift.Bool {
    get
    set
  }
  open func configureSeparatorView()
  @objc deinit
}
public protocol AnyFormValueItemView : Elements.AnyFormItemView {
  var isEditing: Swift.Bool { get set }
  func validate()
}
extension Array : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Array<Element>
}
extension ElementsScope where Base == [Elements.CardType] {
  public func types(forCardNumber cardNumber: Swift.String) -> [Elements.CardType]
  public func type(forCardNumber cardNumber: Swift.String) -> Elements.CardType?
}
open class AbstractPersonalInformationElement : Elements.PaymentElement, Elements.PresentableElement, Elements.Localizable {
  final public let paymentMethod: Elements.PaymentMethod
  weak public var delegate: Elements.PaymentElementDelegate?
  public var viewController: UIKit.UIViewController {
    get
    set
  }
  public var localizationParameters: Elements.LocalizationParameters?
  final public let style: Elements.FormElementStyle
  final public let requiresModalPresentation: Swift.Bool
  final public let configuration: Elements.AbstractPersonalInformationElement.Configuration
  public init(paymentMethod: Elements.PaymentMethod, configuration: Elements.AbstractPersonalInformationElement.Configuration, style: Elements.FormElementStyle = FormElementStyle())
  public var firstNameItem: Elements.FormTextInputItem? {
    get
  }
  public var lastNameItem: Elements.FormTextInputItem? {
    get
  }
  public var emailItem: Elements.FormTextInputItem? {
    get
  }
  public var phoneItem: Elements.FormPhoneNumberItem? {
    get
  }
  open func submitButtonTitle() -> Swift.String
  open func createPaymentDetails() -> Elements.PaymentMethodDetails
  open func getPhoneExtensions() -> [Elements.PhoneExtension]
  @objc deinit
}
public struct CardPaymentMethod : Elements.AnyCardPaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public let cardData: [Elements.SupportedCardData]
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String, fundingSource: Elements.CardFundingSource?, cardData: [Elements.SupportedCardData])
}
public struct StoredCardPaymentMethod : Elements.StoredPaymentMethod, Elements.AnyCardPaymentMethod {
  public let type: Swift.String
  public let identifier: Swift.String
  public let name: Swift.String
  public var cardData: [Elements.SupportedCardData] {
    get
  }
  public var fundingSource: Elements.CardFundingSource?
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public let brand: Swift.String
  public let lastFour: Swift.String
  public let expiryMonth: Swift.String
  public let expiryYear: Swift.String
  public let holderName: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public enum ThemeType {
  case light
  case dark
  public static func == (a: Elements.ThemeType, b: Elements.ThemeType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ElementsTheme : Elements.Theme {
  final public let type: Elements.ThemeType
  final public let identifier: Swift.String
  final public var uiPaddingUnit: CoreGraphics.CGFloat
  final public var themeChangeAnimDuration: Swift.Double
  final public let defaultInteractionAnimationDuration: Swift.Double
  final public let screenWidth: CoreGraphics.CGFloat
  final public let screenHeight: CoreGraphics.CGFloat
  final public var colors: Elements.ColorSchema
  final public var fonts: Elements.FontSchema
  final public var images: Elements.ImageAssets
  public static let light: Elements.ElementsTheme
  public static let dark: Elements.ElementsTheme
  public static let variants: [Elements.ElementsTheme]
  public static let manager: Elements.ThemeManager<Elements.ElementsTheme>
  public init(identifier: Swift.String, type: Elements.ThemeType, colors: Elements.ColorSchema = LightThemeColors(), fonts: Elements.FontSchema = LightThemeFonts(), images: Elements.ImageAssets = LightThemeAssets())
  @objc deinit
}
public enum AppTheme {
  public static var current: Elements.ElementsTheme {
    get
  }
}
extension UIProgressView {
  convenience public init(style: Elements.ProgressViewStyle)
}
public protocol DeviceDependant {
  static func isDeviceSupported() -> Swift.Bool
}
extension ApplePayElement : PassKit.PKPaymentAuthorizationViewControllerDelegate {
  @objc dynamic public func paymentAuthorizationViewControllerDidFinish(_ controller: PassKit.PKPaymentAuthorizationViewController)
  @objc dynamic public func paymentAuthorizationViewController(_ controller: PassKit.PKPaymentAuthorizationViewController, didAuthorizePayment payment: PassKit.PKPayment, completion: @escaping (PassKit.PKPaymentAuthorizationStatus) -> Swift.Void)
}
extension ApplePayElement {
  public struct Configuration {
    public var payment: Elements.Payment
    public let paymentMethod: Elements.ApplePayPaymentMethod
    public var summaryItems: [PassKit.PKPaymentSummaryItem]
    public var merchantIdentifier: Swift.String
    public var merchantName: Swift.String
    public var requiredBillingContactFields: Swift.Set<PassKit.PKContactField>
    public var requiredShippingContactFields: Swift.Set<PassKit.PKContactField>
    public init(payment: Elements.Payment, paymentMethod: Elements.ApplePayPaymentMethod, summaryItems: [PassKit.PKPaymentSummaryItem], merchantIdentifier: Swift.String, merchantName: Swift.String, requiredBillingContactFields: Swift.Set<PassKit.PKContactField> = [], requiredShippingContactFields: Swift.Set<PassKit.PKContactField> = [])
  }
}
public protocol Details : Swift.Encodable {
}
extension Details {
  public var encodable: Elements.AnyEncodable {
    get
  }
}
public protocol PaymentMethodDetails : Elements.Details {
}
public protocol AdditionalDetails : Elements.Details {
}
extension Details {
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
}
public struct CountryCodeValidator : Elements.Validator {
  public init()
  public func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
}
public struct ProgressViewStyle : Elements.ViewStyle {
  public let progressTintColor: UIKit.UIColor
  public let trackTintColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public init(progressTintColor: UIKit.UIColor, trackTintColor: UIKit.UIColor)
}
public protocol AnyAPIServiceProvider : Elements.Element {
  func chargeTransaction(data: Elements.ChargeData, completion: @escaping (Swift.Result<Elements.ChargeAPIResponse, Swift.Error>) -> Swift.Void)
  func handleCreatePayment(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.CreatePaymentMethodResponse, Swift.Error>) -> Swift.Void)
  func handleTokenizeCard(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  func handlePaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  func fetchPaymentMethods(completion: @escaping (Swift.Result<Elements.PaymentMethods, Swift.Error>) -> Swift.Void)
}
public class APIServiceProvider : Elements.AnyAPIServiceProvider {
  public init(environment: Elements.Environment)
  public func chargeTransaction(data: Elements.ChargeData, completion: @escaping (Swift.Result<Elements.ChargeAPIResponse, Swift.Error>) -> Swift.Void)
  public func handleCreatePayment(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.CreatePaymentMethodResponse, Swift.Error>) -> Swift.Void)
  public func handleTokenizeCard(data: Elements.PaymentElementData, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func handlePaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  public func fetchPaymentMethods(completion: @escaping (Swift.Result<Elements.PaymentMethods, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol AnyRetryAPIClient : Elements.APIClientProtocol {
  typealias ShouldRetryHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Bool
  func perform<R>(_ request: R, shouldRetry: Self.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Elements.Request
}
final public class RetryAPIClient : Elements.AnyRetryAPIClient {
  public init(apiClient: Elements.APIClientProtocol, scheduler: Elements.Scheduler)
  final public func perform<R>(_ request: R, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  final public func perform<R>(_ request: R, shouldRetry: Elements.RetryAPIClient.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Elements.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
public protocol FormItemInjector {
  func inject(into formViewController: Elements.FormViewController)
}
final public class FormErrorItem : Elements.FormItem, Elements.Hidable {
  @Elements.Observable @_projectedValueProperty($message) final public var message: Swift.String? {
    get
    set
    _modify
  }
  final public var $message: Elements.Observable<Swift.String?> {
    get
  }
  final public let iconName: Swift.String
  final public let style: Elements.FormErrorItemStyle
  final public var identifier: Swift.String?
  final public var isHidden: Elements.Observable<Swift.Bool>
  final public var subitems: [Elements.FormItem]
  public init(message: Swift.String? = nil, iconName: Swift.String, style: Elements.FormErrorItemStyle = FormErrorItemStyle())
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_inheritsConvenienceInitializers open class BaseFormPickerItemView<T> : Elements.FormValueItemView<Elements.BasePickerElement<T>, Elements.FormTextItemStyle, Elements.BaseFormPickerItem<T>>, UIKit.UIPickerViewDelegate, UIKit.UIPickerViewDataSource where T : Swift.CustomStringConvertible, T : Swift.Equatable {
  required public init(item: Elements.BaseFormPickerItem<T>)
  @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent element: Swift.Int) -> Swift.Int
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, titleForRow row: Swift.Int, forComponent element: Swift.Int) -> Swift.String?
  @objc public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent element: Swift.Int)
  @objc deinit
}
public enum ElementError : Swift.Error {
  case cancelled
  case redirectTokenDoesNotExsits
  case paymentMethodNotSupported
  public static func == (a: Elements.ElementError, b: Elements.ElementError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class WalletsElement : Elements.PaymentElement, Elements.PresentableElement, Elements.LoadingElement {
  final public var paymentMethod: Elements.PaymentMethod {
    get
  }
  weak final public var walletsDelegate: Elements.WalletsElementDelegate?
  weak final public var delegate: Elements.PaymentElementDelegate?
  final public let style: Elements.ListElementStyle
  public init(paymentMethod: Elements.WalletsPaymentMethod, style: Elements.ListElementStyle = ListElementStyle())
  final public var viewController: UIKit.UIViewController {
    get
  }
  final public func stopLoading()
  final public var requiresModalPresentation: Swift.Bool
  @objc deinit
}
extension WalletsElement : Elements.TrackableElement {
}
public protocol WalletsElementDelegate : AnyObject {
  func didSelect(_ paymentMethod: Elements.PaymentMethod, in walletsElement: Elements.WalletsElement)
}
@_hasMissingDesignatedInitializers public class Analytics {
  public enum Flavor : Swift.String {
    case elements, dropin
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Event {
    public var element: Swift.String
    public var flavor: Elements.Analytics.Flavor
    public var environment: Elements.Environment
    public init(element: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  }
  public static var isEnabled: Swift.Bool
  public static func sendEvent(element: Swift.String, flavor: Elements.Analytics.Flavor, environment: Elements.Environment)
  @objc deinit
}
final public class ThemeManager<T> where T : Elements.Theme {
  final public var observers: Foundation.NSHashTable<Swift.AnyObject>
  final public var activeTheme: T {
    get
    set
  }
  public init(default theme: T, persistor: Elements.ThemePersistor = UserDefaults.standard, forceDefault: Swift.Bool = false)
  @objc deinit
}
public enum CancelButtonStyle {
  case system
  case legacy
  case custom(UIKit.UIImage)
}
public enum ToolbarMode {
  case leftCancel
  case rightCancel
  case natural
  public static func == (a: Elements.ToolbarMode, b: Elements.ToolbarMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct NavigationStyle {
  public var backgroundColor: UIKit.UIColor
  public var separatorColor: UIKit.UIColor?
  public var tintColor: UIKit.UIColor?
  public var cornerRadius: CoreGraphics.CGFloat
  public var barTitle: Elements.TextStyle
  public var cancelButton: Elements.CancelButtonStyle
  public var toolbarMode: Elements.ToolbarMode
  public init()
}
final public class FormSplitItem : Elements.FormItem {
  final public let style: Elements.ViewStyle
  final public var identifier: Swift.String?
  final public var subitems: [Elements.FormItem] {
    get
  }
  public init(items: Elements.FormItem..., style: Elements.ViewStyle)
  final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  @objc deinit
}
@_hasMissingDesignatedInitializers open class FormTextItem : Elements.FormValueItem<Swift.String, Elements.FormTextItemStyle>, Elements.ValidatableFormItem, Elements.InputViewRequiringFormItem {
  @Elements.Observable @_projectedValueProperty($placeholder) public var placeholder: Swift.String? {
    get
    set
    _modify
  }
  public var $placeholder: Elements.Observable<Swift.String?> {
    get
  }
  public var formatter: Elements.Formatter?
  public var validator: Elements.Validator?
  public var validationFailureMessage: Swift.String?
  public var autocapitalizationType: UIKit.UITextAutocapitalizationType
  public var autocorrectionType: UIKit.UITextAutocorrectionType
  public var keyboardType: UIKit.UIKeyboardType
  public var contentType: UIKit.UITextContentType?
  public init(style: Elements.FormTextItemStyle)
  public func isValid() -> Swift.Bool
  @objc deinit
}
public protocol Scheduler {
  func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public protocol ViewStyle {
  var backgroundColor: UIKit.UIColor { get set }
}
public protocol TintableStyle : Elements.ViewStyle {
  var tintColor: UIKit.UIColor? { get set }
}
@_inheritsConvenienceInitializers final public class FormTextInputItemView : Elements.FormTextItemView<Elements.FormTextInputItem> {
  required public init(item: Elements.FormTextInputItem)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CardNumberFormatter : Elements.NumericFormatter {
  final public var cardType: Elements.CardType?
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  override public init()
  @objc deinit
}
@objc public protocol StripeFormEncodable : ObjectiveC.NSObjectProtocol {
  @objc static func rootObjectName() -> Swift.String?
  @objc static func propertyNamesToFormFieldNamesMapping() -> [Swift.String : Swift.String]
  @objc var additionalAPIParameters: [Swift.AnyHashable : Any] { get set }
}
public enum TokenizationVaultOption : Swift.String, Swift.Codable {
  case singleUse
  case reusable
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol ElementsAPIClientType : AnyObject {
  func tokenizeCard(data: Elements.ElementsCardParams, idempotencyKey: Swift.String, vaultOption: Elements.TokenizationVaultOption, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  func performPaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, config: Elements.PaymentSetupModel, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
}
public class ElementsAPIClientConfiguration {
  final public let environment: Elements.Environment
  final public let pspCustomers: [Elements.PspCustomer]?
  final public let stripePublishableKey: Swift.String?
  public init(environment: Elements.Environment, pspCustomers: [Elements.PspCustomer]? = nil, stripePublishableKey: Swift.String? = nil)
  @objc deinit
}
public class ElementsAPIClient : Elements.ElementsAPIClientType {
  public init(config: Elements.ElementsAPIClientConfiguration)
  public func tokenizeCard(data: Elements.ElementsCardParams, idempotencyKey: Swift.String = UUID().uuidString, vaultOption: Elements.TokenizationVaultOption = .reusable, completion: @escaping (Swift.Result<Elements.VaultTokens, Swift.Error>) -> Swift.Void)
  public func performPaymentsSetup(data: Elements.PaymentElementData, token: Swift.String?, config: Elements.PaymentSetupModel, completion: @escaping (Swift.Result<Elements.PaymentsResponse, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension ElementsScope where Base : UIKit.UIView {
  public func round(corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, precentage: CoreGraphics.CGFloat)
  public func round(corners: UIKit.UIRectCorner, rounding: Elements.CornerRounding)
  public func round(using rounding: Elements.CornerRounding)
}
public struct ElementsAPIError : Swift.Decodable, Swift.Error, Foundation.LocalizedError {
  public var status: Swift.Int?
  public let errorCode: Swift.String
  public let errorMessage: Swift.String
  public let type: Elements.APIErrorType
  public var errorDescription: Swift.String? {
    get
  }
  public init(status: Swift.Int?, errorCode: Swift.String, errorMessage: Swift.String, type: Elements.APIErrorType)
  public init(from decoder: Swift.Decoder) throws
}
public enum APIErrorType : Swift.String, Swift.Decodable {
  case cardError
  case apiError
  case authenticationError
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UILabel {
  convenience public init(style: Elements.TextStyle)
}
public struct RedirectElementStyle {
  public let preferredBarTintColor: UIKit.UIColor?
  public let preferredControlTintColor: UIKit.UIColor
  public let modalPresentationStyle: UIKit.UIModalPresentationStyle
  public init(preferredBarTintColor: UIKit.UIColor? = nil, preferredControlTintColor: UIKit.UIColor = .systemBlue, modalPresentationStyle: UIKit.UIModalPresentationStyle = .formSheet)
}
public protocol ThemePersistor {
  func retreiveThemeId() -> Swift.String?
  func saveThemeId(_ identifier: Swift.String)
}
extension UserDefaults : Elements.ThemePersistor {
  public func retreiveThemeId() -> Swift.String?
  public func saveThemeId(_ identifier: Swift.String)
}
final public class FormPhoneNumberItem : Elements.FormTextItem {
  final public var prefix: Swift.String {
    get
  }
  final public var phoneNumber: Swift.String {
    get
  }
  public init(selectableValues: [Elements.PhoneExtensionPickerItem], style: Elements.FormTextItemStyle, localizationParameters: Elements.LocalizationParameters? = nil)
  override final public func build(with builder: Elements.FormItemViewBuilder) -> Elements.AnyFormItemView
  override public init(style: Elements.FormTextItemStyle)
  @objc deinit
}
extension URL {
  public var queryParameters: [Swift.String : Swift.String] {
    get
  }
  public var isHttp: Swift.Bool {
    get
  }
}
public struct Payment {
  public struct Amount {
    public var value: Swift.Int
    public var currencyCode: Swift.String
    public init(value: Swift.Int, currencyCode: Swift.String)
    public init(value: Foundation.Decimal, currencyCode: Swift.String)
  }
  public var amount: Elements.Payment.Amount
  public var countryCode: Swift.String?
  public init(amount: Elements.Payment.Amount, countryCode: Swift.String? = nil)
}
extension Payment.Amount {
  public var formatted: Swift.String {
    get
  }
}
public protocol PickerElement : Swift.CustomStringConvertible, Swift.Equatable {
  var identifier: Swift.String { get }
}
public struct BasePickerElement<ElementType> : Elements.PickerElement where ElementType : Swift.CustomStringConvertible {
  public let identifier: Swift.String
  public let element: ElementType
  public static func == (lhs: Elements.BasePickerElement<ElementType>, rhs: Elements.BasePickerElement<ElementType>) -> Swift.Bool
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class BaseFormPickerItem<ElementType> : Elements.FormValueItem<Elements.BasePickerElement<ElementType>, Elements.FormTextItemStyle>, Elements.InputViewRequiringFormItem where ElementType : Swift.CustomStringConvertible {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class ListCell : UIKit.UITableViewCell {
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @available(*, unavailable)
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  final public var item: Elements.ListItem? {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CardExpiryDateValidator : Elements.Validator {
  public init()
  final public func isValid(_ string: Swift.String) -> Swift.Bool
  final public func maximumLength(for value: Swift.String) -> Swift.Int
  @objc deinit
}
public struct IssuerListPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let issuers: [Elements.IssuerListPaymentMethod.Issuer]
  public struct Issuer : Swift.Decodable {
    public let identifier: Swift.String
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public init(from decoder: Swift.Decoder) throws
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
}
public struct VaultTokens {
  public let elementsToken: Elements.ElementsToken?
  public let fallbackStripeToken: Elements.StripeVaultToken?
}
public struct TokenizationResponse : Elements.Response {
  public let token: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
final public class IBANFormatter : Elements.Formatter {
  public init()
  final public func formattedValue(for value: Swift.String) -> Swift.String
  final public func sanitizedValue(for value: Swift.String) -> Swift.String
  @objc deinit
}
public protocol Localizable {
  var localizationParameters: Elements.LocalizationParameters? { get set }
}
public protocol Cancellable : AnyObject {
  func didCancel()
}
public protocol PresentableElement : Elements.Element {
  var requiresModalPresentation: Swift.Bool { get }
  var viewController: UIKit.UIViewController { get }
}
extension PresentableElement {
  public var requiresModalPresentation: Swift.Bool {
    get
  }
}
public protocol TrackableElement : Elements.Element, Elements.PaymentMethodAware, Elements.ViewControllerDelegate {
}
extension TrackableElement {
  public func viewDidLoad(viewController: UIKit.UIViewController)
  public func viewDidAppear(viewController: UIKit.UIViewController)
}
open class LengthValidator : Elements.Validator {
  open var minimumLength: Swift.Int?
  open var maximumLength: Swift.Int?
  public init(minimumLength: Swift.Int? = nil, maximumLength: Swift.Int? = nil)
  open func isValid(_ value: Swift.String) -> Swift.Bool
  public func maximumLength(for _: Swift.String) -> Swift.Int
  @objc deinit
}
public struct RedirectPaymentMethod : Elements.PaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(type: Swift.String, name: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
public struct StoredRedirectPaymentMethod : Elements.StoredPaymentMethod {
  public let type: Swift.String
  public let name: Swift.String
  public let identifier: Swift.String
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(from decoder: Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers final public class SecuredViewController : UIKit.UIViewController {
  weak final public var delegate: Elements.ViewControllerDelegate?
  @objc override final public var preferredContentSize: CoreGraphics.CGSize {
    @objc get
    @objc set
  }
  @objc override final public var title: Swift.String? {
    @objc get
    @objc set
  }
  public init(child: UIKit.UIViewController, style: Elements.ViewStyle)
  @objc deinit
  @objc override final public func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public struct StoredPayPalPaymentMethod : Elements.StoredPaymentMethod {
  public let type: Swift.String
  public let identifier: Swift.String
  public let name: Swift.String
  public let supportedShopperInteractions: [Elements.ShopperInteraction]
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  public let emailAddress: Swift.String
  public func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
  public init(from decoder: Swift.Decoder) throws
}
public struct UnknownError : Swift.Error, Foundation.LocalizedError {
  public var errorDescription: Swift.String?
  public init(errorDescription: Swift.String? = nil)
}
public struct ThreeDS2ChallengeAction : Swift.Decodable {
  public let challengeToken: Swift.String
  public let authorisationToken: Swift.String?
  public let paymentData: Swift.String?
  public init(challengeToken: Swift.String, authorisationToken: Swift.String? = nil, paymentData: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
}
public enum CardType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case accel
  case alphaBankBonusMasterCard
  case alphaBankBonusVISA
  case argencard
  case americanExpress
  case bcmc
  case bijenkorfCard
  case cabal
  case carteBancaire
  case cencosud
  case chequeDejeneur
  case chinaUnionPay
  case codensa
  case creditUnion24
  case dankort
  case dankortVISA
  case diners
  case discover
  case elo
  case forbrugsforeningen
  case hiper
  case hipercard
  case jcb
  case karenMillen
  case kcp
  case laser
  case maestro
  case maestroUK
  case masterCard
  case mir
  case naranja
  case netplus
  case nyce
  case oasis
  case pulse
  case shopping
  case solo
  case star
  case troy
  case uatp
  case visa
  case warehouse
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [Elements.CardType]
  public static var allCases: [Elements.CardType] {
    get
  }
}
public protocol PaymentMethod : Swift.Decodable {
  var type: Swift.String { get }
  var name: Swift.String { get }
  var displayInformation: Elements.DisplayInformation { get }
  func localizedDisplayInformation(using parameters: Elements.LocalizationParameters?) -> Elements.DisplayInformation
  func buildElement(using builder: Elements.PaymentElementBuilder) -> Elements.PaymentElement?
}
public struct DisplayInformation {
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var logoName: Swift.String
}
extension DisplayInformation : Swift.Equatable {
  public static func == (a: Elements.DisplayInformation, b: Elements.DisplayInformation) -> Swift.Bool
}
extension PaymentMethod {
  public var displayInformation: Elements.DisplayInformation {
    get
  }
  public func localizedDisplayInformation(using _: Elements.LocalizationParameters?) -> Elements.DisplayInformation
}
public protocol StoredPaymentMethod : Elements.PaymentMethod {
  var identifier: Swift.String { get }
  var supportedShopperInteractions: [Elements.ShopperInteraction] { get }
}
public struct ActionElementData {
  public let details: Elements.AdditionalDetails
  public let paymentData: Swift.String?
  public init(details: Elements.AdditionalDetails, paymentData: Swift.String?)
}
@objc @_hasMissingDesignatedInitializers final public class CopyLabelView : UIKit.UIView, Elements.Localizable {
  final public var localizationParameters: Elements.LocalizationParameters?
  public init(text: Swift.String, style: Elements.TextStyle)
  @objc deinit
  @objc override final public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc override final public func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
final public class StripeAPIClient {
  public typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  public init(publishableKey: Swift.String, stripeAccount: Swift.String?)
  final public func perform<R>(_ request: R, parameters: [Swift.String : Any], completionHandler: @escaping Elements.StripeAPIClient.CompletionHandler<R.ResponseType>) where R : Elements.Request
  @objc deinit
}
@objc public class StripeAppInfo : ObjectiveC.NSObject {
  public init(name: Swift.String, partnerId: Swift.String?, version: Swift.String?, url: Swift.String?)
  public var name: Swift.String {
    get
  }
  public var partnerId: Swift.String? {
    get
  }
  public var version: Swift.String? {
    get
  }
  public var url: Swift.String? {
    get
  }
  @objc deinit
  @objc override dynamic public init()
}
public struct PaymentSetupModel : Swift.Codable {
  public let returnURL: Swift.String
  public let cancelURL: Swift.String
  public init(returnURLScheme: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PaymentsSetupRequest : Elements.Request {
  public typealias ResponseType = Elements.PaymentsResponse
  public let path: Swift.String
  public var counter: Swift.UInt
  public var method: Elements.HTTPMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
  public init(data: Elements.PaymentElementData, encodedToken: Swift.String?, config: Elements.PaymentSetupModel)
}
public struct BrowserInfo : Swift.Encodable {
  public var userAgent: Swift.String? {
    get
  }
  public static func initialize(completion: @escaping ((Elements.BrowserInfo?) -> Swift.Void))
  public func encode(to encoder: Swift.Encoder) throws
}
extension ElementsScope where Base : UIKit.UIView {
  @discardableResult
  public func anchore(inside view: UIKit.UIView, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func anchore(inside margines: UIKit.UILayoutGuide, with padding: UIKit.UIEdgeInsets = .zero) -> [UIKit.NSLayoutConstraint]
  public func wrapped(with insets: UIKit.UIEdgeInsets = .zero) -> UIKit.UIView
}
@_inheritsConvenienceInitializers final public class CardExpiryDateFormatter : Elements.NumericFormatter {
  override final public func formattedValue(for value: Swift.String) -> Swift.String
  override public init()
  @objc deinit
}
public struct Environment : Elements.APIEnvironment {
  public var baseURL: Foundation.URL
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public var queryParameters: [Foundation.URLQueryItem]
  public let clientToken: Swift.String
  public static func sandbox(clientToken: Swift.String) -> Elements.Environment
  public static func portForward(clientToken: Swift.String) -> Elements.Environment
  public static func production(clientToken: Swift.String) -> Elements.Environment
  public static let unknown: Elements.Environment
  public init(baseURL: Foundation.URL? = nil, clientToken: Swift.String)
}
final public class ElementsActionHandler : Elements.ActionElement, Elements.Localizable {
  weak final public var delegate: Elements.ActionElementDelegate?
  weak final public var presentationDelegate: Elements.PresentationDelegate?
  final public var redirectElementStyle: Elements.RedirectElementStyle?
  final public var awaitElementStyle: Elements.AwaitElementStyle?
  final public var localizationParameters: Elements.LocalizationParameters?
  public init()
  final public func handle(_ action: Elements.Action)
  @objc deinit
}
public struct CardBrand : Swift.Decodable {
  public let type: Elements.CardType
  public let isSupported: Swift.Bool
  public enum CVCPolicy : Swift.String, Swift.Decodable {
    case required
    case optional
    case hidden
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(from decoder: Swift.Decoder) throws
}
extension CardBrand : Swift.Equatable {
  public static func == (a: Elements.CardBrand, b: Elements.CardBrand) -> Swift.Bool
}
public struct SupportedCardData : Swift.Decodable {
  public let brand: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case brand
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(brand: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
extension String : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.String
}
extension Optional : Elements.ElementsCompatible {
  public typealias ElementsBase = Swift.Optional<Wrapped>
}
extension ElementsScope where Base == Swift.String? {
  public var isNullOrEmpty: Swift.Bool {
    get
  }
}
extension ElementsScope where Base == Swift.String {
  public var nilIfEmpty: Swift.String? {
    get
  }
  public func truncate(to length: Swift.Int) -> Swift.String
  public func elements(withLengths lengths: [Swift.Int]) -> [Swift.String]
  public func elements(withLength length: Swift.Int) -> [Swift.String]
  public subscript(position: Swift.Int) -> Swift.String {
    get
  }
  public subscript(range: Swift.Range<Swift.Int>) -> Swift.String {
    get
  }
  public subscript(range: Swift.ClosedRange<Swift.Int>) -> Swift.String {
    get
  }
}
public struct IBANSpecification {
  public static let highestMaximumLength: Swift.Int
  public let countryCode: Swift.String
  public let length: Swift.Int
  public let structure: Swift.String
  public let example: Swift.String
  public init?(forCountryCode countryCode: Swift.String)
}
public struct FormSwitchItemStyle : Elements.FormValueItemStyle {
  public var title: Elements.TextStyle
  public var tintColor: UIKit.UIColor?
  public var separatorColor: UIKit.UIColor?
  public var backgroundColor: UIKit.UIColor
  public init(title: Elements.TextStyle)
  public init()
}
public enum Coder {
  public static func decode<T>(_ data: Foundation.Data) throws -> T where T : Swift.Decodable
  public static func decode<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func decodeBase64<T>(_ string: Swift.String) throws -> T where T : Swift.Decodable
  public static func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  public static func encode<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
  public static func encodeBase64<T>(_ value: T) throws -> Swift.String where T : Swift.Encodable
}
public enum CornerRounding {
  case none
  case fixed(CoreGraphics.CGFloat)
  case percent(CoreGraphics.CGFloat)
}
extension CornerRounding : Swift.Equatable {
  public static func == (lhs: Elements.CornerRounding, rhs: Elements.CornerRounding) -> Swift.Bool
}
public protocol EventPublisher : AnyObject {
  associatedtype Event
  var eventHandlers: [Elements.EventHandlerToken : Elements.EventHandler<Self.Event>] { get set }
}
extension EventPublisher {
  public func addEventHandler(_ eventHandler: @escaping Elements.EventHandler<Self.Event>) -> Elements.EventHandlerToken
  public func removeEventHandler(with token: Elements.EventHandlerToken)
  public func publish(_ event: Self.Event)
}
public typealias EventHandler<Event> = (Event) -> Swift.Void
public struct EventHandlerToken : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Elements.EventHandlerToken, b: Elements.EventHandlerToken) -> Swift.Bool
}
public struct StripeVaultToken : Elements.Response {
  public let id: Swift.String
  public let type: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
extension Elements.ApplePayElement.Error : Swift.Equatable {}
extension Elements.ApplePayElement.Error : Swift.Hashable {}
extension Elements.RedirectElement.Error : Swift.Equatable {}
extension Elements.RedirectElement.Error : Swift.Hashable {}
extension Elements.BillingAddressFields : Swift.Equatable {}
extension Elements.BillingAddressFields : Swift.Hashable {}
extension Elements.BillingAddressFields : Swift.RawRepresentable {}
extension Elements.CardElement.AddressFormType : Swift.Equatable {}
extension Elements.CardElement.AddressFormType : Swift.Hashable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Equatable {}
extension Elements.PhoneNumberPaymentMethod : Swift.Hashable {}
extension Elements.SupportedPspType : Swift.Equatable {}
extension Elements.SupportedPspType : Swift.Hashable {}
extension Elements.SupportedPspType : Swift.RawRepresentable {}
extension Elements.ElementsTokenizationStatus : Swift.Equatable {}
extension Elements.ElementsTokenizationStatus : Swift.Hashable {}
extension Elements.ElementsTokenizationStatus : Swift.RawRepresentable {}
extension Elements.CardFundingSource : Swift.Equatable {}
extension Elements.CardFundingSource : Swift.Hashable {}
extension Elements.CardFundingSource : Swift.RawRepresentable {}
extension Elements.ThreeDS2Action.ActionType : Swift.Equatable {}
extension Elements.ThreeDS2Action.ActionType : Swift.Hashable {}
extension Elements.ThreeDS2Action.ActionType : Swift.RawRepresentable {}
extension Elements.CardElement.Error : Swift.Equatable {}
extension Elements.CardElement.Error : Swift.Hashable {}
extension Elements.ShopperInteraction : Swift.Equatable {}
extension Elements.ShopperInteraction : Swift.Hashable {}
extension Elements.ShopperInteraction : Swift.RawRepresentable {}
extension Elements.AppImageName : Swift.Equatable {}
extension Elements.AppImageName : Swift.Hashable {}
extension Elements.AppImageName : Swift.RawRepresentable {}
extension Elements.HTTPMethod : Swift.Equatable {}
extension Elements.HTTPMethod : Swift.Hashable {}
extension Elements.HTTPMethod : Swift.RawRepresentable {}
extension Elements.LogoURLProvider.Size : Swift.Equatable {}
extension Elements.LogoURLProvider.Size : Swift.Hashable {}
extension Elements.LogoURLProvider.Size : Swift.RawRepresentable {}
extension Elements.AwaitPaymentMethod : Swift.Equatable {}
extension Elements.AwaitPaymentMethod : Swift.Hashable {}
extension Elements.AwaitPaymentMethod : Swift.RawRepresentable {}
extension Elements.ThemeType : Swift.Equatable {}
extension Elements.ThemeType : Swift.Hashable {}
extension Elements.ElementError : Swift.Equatable {}
extension Elements.ElementError : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.Equatable {}
extension Elements.Analytics.Flavor : Swift.Hashable {}
extension Elements.Analytics.Flavor : Swift.RawRepresentable {}
extension Elements.ToolbarMode : Swift.Equatable {}
extension Elements.ToolbarMode : Swift.Hashable {}
extension Elements.TokenizationVaultOption : Swift.Equatable {}
extension Elements.TokenizationVaultOption : Swift.Hashable {}
extension Elements.TokenizationVaultOption : Swift.RawRepresentable {}
extension Elements.APIErrorType : Swift.Equatable {}
extension Elements.APIErrorType : Swift.Hashable {}
extension Elements.APIErrorType : Swift.RawRepresentable {}
extension Elements.CardType : Swift.Equatable {}
extension Elements.CardType : Swift.Hashable {}
extension Elements.CardType : Swift.RawRepresentable {}
extension Elements.CardBrand.CVCPolicy : Swift.Equatable {}
extension Elements.CardBrand.CVCPolicy : Swift.Hashable {}
extension Elements.CardBrand.CVCPolicy : Swift.RawRepresentable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Equatable {}
extension Elements.SupportedCardData.CodingKeys : Swift.Hashable {}
extension Elements.SupportedCardData.CodingKeys : Swift.RawRepresentable {}
